<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EventDispatcher.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade.old.internal</a> &gt; <span class="el_source">EventDispatcher.java</span></div><h1>EventDispatcher.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade.old.internal;

import com.google.common.base.Verify;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimaps;
import com.google.common.collect.SetMultimap;
import com.mackenziehigh.cascade.CascadeToken;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 *
 */
public final class EventDispatcher
{
    /**
     * Empty List.
     */
<span class="fc" id="L28">    private final ImmutableList&lt;InflowQueue&gt; EMPTY_LIST = ImmutableList.of();</span>

    /**
     * (subscriber) -&gt; (queue).
     *
     * &lt;p&gt;
     * This map maps the name of a subscriber to the inflow-queue that
     * stores the pending event-messages flowing into that subscriber.
     * &lt;/p&gt;
     */
    private final ImmutableSortedMap&lt;CascadeToken, InflowQueue&gt; subscribersToInflowQueues;

    /**
     * (event) -&gt; [ (queue) ].
     *
     * &lt;p&gt;
     * This map maps the name of an event to the inflow-queues that feed
     * event-messages to the subscribers interested in that event.
     * &lt;/p&gt;
     */
<span class="fc" id="L48">    private final Map&lt;CascadeToken, ImmutableList&lt;InflowQueue&gt;&gt; eventsToSubscriberQueues = Maps.newConcurrentMap();</span>

    /**
     * (publisher) -&gt; (sender).
     *
     * &lt;p&gt;
     * This method maps the name of a publisher to an object that can
     * be used to send event-messages in an orderly and atomic manner.
     * Whenever an event-message is sent using the sender object,
     * the sender object will resolve the list of inflow-queues
     * pertaining to the subscribers that are interested in
     * the message being sent, and then, the sender object
     * will enqueue the even-message in those inflow-queues,
     * if possible.
     * &lt;/p&gt;
     */
<span class="fc" id="L64">    private final Map&lt;CascadeToken, ConcurrentEventSender&gt; senders = Maps.newConcurrentMap();</span>

    /**
     * (event) -&gt; [ (subscriber) ].
     *
     * &lt;p&gt;
     * This method maps the name of an event to the names of the subscribers
     * that are currently interested in receiving that type of event.
     * &lt;/p&gt;
     */
<span class="fc" id="L74">    private final SetMultimap&lt;CascadeToken, CascadeToken&gt; eventsToSubscribers = Multimaps.synchronizedSetMultimap(HashMultimap.create());</span>

    /**
     * (subscriber) -&gt; [ (event) ].
     *
     * &lt;p&gt;
     * This method maps the name of a subscriber to the names of the events
     * that the subscriber is currently interested in receiving.
     * &lt;/p&gt;
     */
<span class="fc" id="L84">    private final SetMultimap&lt;CascadeToken, CascadeToken&gt; subscribersToEvents = Multimaps.synchronizedSetMultimap(HashMultimap.create());</span>

    /**
     * This lock is used to ensure that registrations, de-registrations, and look-ups are synchronous.
     */
<span class="fc" id="L89">    private final Lock lock = new ReentrantLock();</span>

    /**
     * Sole constructor.
     *
     * @param queues maps subscribers to their input sources.
     */
    public EventDispatcher (final Map&lt;CascadeToken, InflowQueue&gt; queues)
<span class="fc" id="L97">    {</span>
<span class="fc" id="L98">        this.subscribersToInflowQueues = ImmutableSortedMap.copyOf(queues);</span>
<span class="fc" id="L99">    }</span>

    /**
     * Use this method to find the names of any subscribers that
     * are currently registered to receive the given event.
     *
     * @param eventId identifies the event-channel.
     * @return the subscribes to the given event-channel.
     */
    public Set&lt;CascadeToken&gt; subscribersOf (final CascadeToken eventId)
    {
<span class="fc" id="L110">        return ImmutableSet.copyOf(eventsToSubscribers.get(eventId));</span>
    }

    /**
     * Use this method to find the names of any events that
     * a subscriber with a given name is registered to receive.
     *
     * @param subscriberId identifies the subscriber.
     * @return the names of the events, if any.
     */
    public Set&lt;CascadeToken&gt; subscriptionsOf (final CascadeToken subscriberId)
    {
<span class="fc" id="L122">        return ImmutableSet.copyOf(subscribersToEvents.get(subscriberId));</span>
    }

    /**
     * Register a message-queue to receive messages for a given event.
     *
     * @param subscriberId will now receive messages for (eventId).
     * @param eventId identifies the event to listen for.
     */
    public void register (final CascadeToken subscriberId,
                          final CascadeToken eventId)
    {
<span class="fc" id="L134">        lock.lock();</span>

        try
        {
<span class="fc" id="L138">            performRegister(subscriberId, eventId);</span>
        }
        finally
        {
<span class="fc" id="L142">            lock.unlock();</span>
<span class="fc" id="L143">        }</span>
<span class="fc" id="L144">    }</span>

    private void performRegister (final CascadeToken subscriberId,
                                  final CascadeToken eventId)
    {
<span class="fc" id="L149">        final InflowQueue handler = subscribersToInflowQueues.get(subscriberId);</span>

<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (handler != null)</span>
        {
            /**
             * Subscribe the subscriber to the event-channel.
             * This is slow, O(N) copy each time, but we need an immutable list during sends.
             * Given that the number of subscribers is expected to be a small number (usually);
             * therefore, the trade-off is acceptable here at this time.
             * In theory, we could use a truly functional data-structure.
             * Unfortunately, we do not have such a data-structure conveniently
             * available and adding a dependency just for this is not justifiable now.
             */
<span class="fc" id="L162">            final ImmutableList&lt;InflowQueue&gt; original = eventsToSubscriberQueues.getOrDefault(eventId, ImmutableList.of());</span>
<span class="fc" id="L163">            final ImmutableList&lt;InflowQueue&gt; modified = ImmutableList.&lt;InflowQueue&gt;builder().addAll(original).add(handler).build();</span>
<span class="fc" id="L164">            eventsToSubscriberQueues.put(eventId, modified);</span>
<span class="fc" id="L165">            eventsToSubscribers.put(eventId, subscriberId);</span>
<span class="fc" id="L166">            subscribersToEvents.put(subscriberId, eventId);</span>
<span class="fc" id="L167">        }</span>
        else
        {
<span class="fc" id="L170">            throw new IllegalArgumentException(&quot;No Such Subscriber: &quot; + subscriberId);</span>
        }
<span class="fc" id="L172">    }</span>

    /**
     * Deregister a message-queue from receiving message for a given event.
     *
     * @param subscriberId will no longer receive messages for (eventId).
     * @param eventId identifies the event to no longer listen for.
     */
    public void deregister (final CascadeToken subscriberId,
                            final CascadeToken eventId)
    {
<span class="fc" id="L183">        lock.lock();</span>

        try
        {
<span class="fc" id="L187">            performDeregister(subscriberId, eventId);</span>
        }
        finally
        {
<span class="pc" id="L191">            lock.unlock();</span>
<span class="fc" id="L192">        }</span>
<span class="fc" id="L193">    }</span>

    private void performDeregister (final CascadeToken subscriberId,
                                    final CascadeToken eventId)
    {
        /**
         * If no one was subscribed to the event,
         * then an this should simply be a no-op.
         */
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (eventsToSubscriberQueues.containsKey(eventId) == false)</span>
        {
<span class="fc" id="L204">            return;</span>
        }

        /**
         * Unsubscribe the subscriber from the event-channel.
         * This is slow, O(N) copy each time.
         * See the discussion in the registration method.
         */
<span class="fc" id="L212">        final InflowQueue removeThis = subscribersToInflowQueues.get(subscriberId);</span>
<span class="fc" id="L213">        final List&lt;InflowQueue&gt; original = Lists.newArrayList(eventsToSubscriberQueues.getOrDefault(eventId, ImmutableList.of()));</span>
<span class="fc" id="L214">        final int originalSize = original.size();</span>
<span class="fc" id="L215">        original.removeIf(x -&gt; x.equals(removeThis));</span>
<span class="fc" id="L216">        final ImmutableList&lt;InflowQueue&gt; modified = ImmutableList.copyOf(original);</span>
<span class="fc" id="L217">        final int modifiedSize = modified.size();</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">        Verify.verify(modifiedSize == (originalSize - 1));</span>
<span class="fc" id="L219">        eventsToSubscriberQueues.put(eventId, modified);</span>
<span class="fc" id="L220">        eventsToSubscribers.remove(eventId, subscriberId);</span>
<span class="fc" id="L221">        subscribersToEvents.remove(subscriberId, eventId);</span>
<span class="fc" id="L222">    }</span>

    /**
     * Use this method to lookup the special object that event-producers shall use to dispatch events.
     *
     * &lt;p&gt;
     * Per use-site, this method should be called once and then the result cached.
     * &lt;/p&gt;
     *
     * @param publisherId identifies the logical entity that will dispatch-events.
     * @return the API for sending events.
     */
    public ConcurrentEventSender lookup (final CascadeToken publisherId)
    {
<span class="fc" id="L236">        lock.lock();</span>

        try
        {
<span class="fc" id="L240">            return performLookup(publisherId);</span>
        }
        finally
        {
<span class="pc" id="L244">            lock.unlock();</span>
        }
    }

    private ConcurrentEventSender performLookup (final CascadeToken publisherId)
    {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (senders.containsKey(publisherId) == false)</span>
        {
<span class="fc" id="L252">            senders.put(publisherId, new ConcurrentEventSender());</span>
        }

<span class="fc" id="L255">        final ConcurrentEventSender result = senders.get(publisherId);</span>

<span class="fc" id="L257">        return result;</span>
    }

    /**
     * Use this API to send events.
     */
<span class="fc" id="L263">    public final class ConcurrentEventSender</span>
            extends OrderlyAtomicSender
    {

        /**
         * Private.
         *
         * @param eventId identifies the event being sent.
         * @param out will receive the connections to the subscribers that are interested in the event.
         */
        @Override
        public void resolveConnections (final CascadeToken eventId,
                                        final ArrayList&lt;InflowQueue&gt; out)
        {
            /**
             * The list is expected to be reused.
             * Make sure the list is actually clear.
             */
<span class="fc" id="L281">            out.clear();</span>

            /**
             * Resolve the interested subscribers and add them to the output list.
             * I am deliberately using a int-based for loop here,
             * rather than a for-each loop or an addAll() method,
             * because I do not want to cause an Iterator object to be allocated.
             * Due to the frequency with which this method will be invoked,
             * that would be a lot of unnecessary garbage.
             */
<span class="fc" id="L291">            final ImmutableList&lt;InflowQueue&gt; connections = eventsToSubscriberQueues.getOrDefault(eventId, EMPTY_LIST);</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">            for (int i = 0; i &lt; connections.size(); i++)</span>
            {
<span class="fc" id="L294">                final InflowQueue connection = connections.get(i);</span>
<span class="fc" id="L295">                Verify.verifyNotNull(connection);</span>
<span class="fc" id="L296">                out.add(connection);</span>
            }
<span class="fc" id="L298">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>