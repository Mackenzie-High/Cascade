<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConcreteCascade.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade.old.internal</a> &gt; <span class="el_source">ConcreteCascade.java</span></div><h1>ConcreteCascade.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade.old.internal;

import com.google.common.base.Verify;
import com.mackenziehigh.cascade.old.Cascade;
import com.mackenziehigh.cascade.old.CascadeAllocator;
import com.mackenziehigh.cascade.old.CascadeAllocator.OperandStack;
import com.mackenziehigh.cascade.old.CascadePump;
import com.mackenziehigh.cascade.old.CascadeReactor;
import com.mackenziehigh.cascade.old.CascadeReactor.Context;
import com.mackenziehigh.cascade.CascadeToken;
import java.util.Collections;
import java.util.SortedMap;
import java.util.UUID;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 *
 */
<span class="fc" id="L23">public final class ConcreteCascade</span>
        implements Cascade
{
    private volatile CascadeToken name;

<span class="fc" id="L28">    private final UUID uuid = UUID.randomUUID();</span>

    private volatile CascadeAllocator allocator;

<span class="fc" id="L32">    private final SortedMap&lt;CascadeToken, ConcretePump&gt; pumps = new ConcurrentSkipListMap&lt;&gt;();</span>

<span class="fc" id="L34">    private final SortedMap&lt;CascadeToken, CascadePump&gt; unmodPumps = Collections.unmodifiableSortedMap(pumps);</span>

<span class="fc" id="L36">    private final SortedMap&lt;CascadeToken, ConcreteReactor&gt; reactors = new ConcurrentSkipListMap&lt;&gt;();</span>

<span class="fc" id="L38">    private final SortedMap&lt;CascadeToken, CascadeReactor&gt; unmodReactors = Collections.unmodifiableSortedMap(reactors);</span>

<span class="fc" id="L40">    private final AtomicInteger phaseIdx = new AtomicInteger();</span>

<span class="fc" id="L42">    private final AtomicBoolean startWasCalled = new AtomicBoolean();</span>

<span class="fc" id="L44">    private final AtomicBoolean stopWasCalled = new AtomicBoolean();</span>

    /**
     * This latch prevents the stop thread from making progress
     * while the start thread is still in-progress.
     */
<span class="fc" id="L50">    private final CountDownLatch stopLatch = new CountDownLatch(1);</span>

    /**
     * This latch becomes permanently unblocked once this system comes to a complete stop.
     */
<span class="fc" id="L55">    private final CountDownLatch awaitLatch = new CountDownLatch(1);</span>

    /**
     * Invariant Checking.
     */
    public void selfTest ()
    {
<span class="fc" id="L62">        Verify.verifyNotNull(name());</span>
<span class="fc" id="L63">        Verify.verifyNotNull(uuid());</span>
<span class="fc" id="L64">        Verify.verifyNotNull(phase());</span>
<span class="fc" id="L65">        Verify.verifyNotNull(pumps());</span>
<span class="fc" id="L66">        Verify.verifyNotNull(reactors());</span>

<span class="fc" id="L68">        Verify.verify(name().toString().equals(toString()));</span>
<span class="fc" id="L69">        Verify.verify(phase().equals(ExecutionPhase.INITIAL));</span>
<span class="fc" id="L70">        Verify.verify(allocator().cascade().equals(this));</span>

<span class="fc" id="L72">        Verify.verify(phase().equals(phase()));</span>
<span class="fc" id="L73">        Verify.verify(uuid().equals(uuid()));</span>

        /**
         * pumps() must map the name of a pump to that pump.
         * Each pump must have this object as its cascade().
         */
<span class="pc bpc" id="L79" title="2 of 4 branches missed.">        Verify.verify(pumps().values().stream().allMatch(x -&gt; x.cascade().equals(this) &amp;&amp; pumps().get(x.name()).equals(x)));</span>

        /**
         * reactors() must map the name of a reactor to that reactor.
         * Each reactor must have this object as its cascade().
         */
<span class="pc bpc" id="L85" title="2 of 4 branches missed.">        Verify.verify(reactors().values().stream().allMatch(x -&gt; x.cascade().equals(this) &amp;&amp; reactors().get(x.name()).equals(x)));</span>

        /**
         * Verify that all of the pumps known-by the reactors
         * are also directly known by this object as well.
         */
<span class="fc bfc" id="L91" title="All 2 branches covered.">        if (reactors.size() &gt; 0)</span>
        {
<span class="fc" id="L93">            Verify.verify(pumps().values().containsAll(reactors().values().stream().map(x -&gt; x.pump()).collect(Collectors.toSet())));</span>
        }

        /**
         * Verify that all of the reactors known-by the pumps
         * are also directly known by this object as well.
         */
<span class="fc" id="L100">        Verify.verify(reactors().values().containsAll(pumps().values().stream().map(x -&gt; x.reactors()).flatMap(x -&gt; x.stream()).collect(Collectors.toSet())));</span>
<span class="fc" id="L101">    }</span>

    public void setName (final CascadeToken value)
    {
<span class="fc" id="L105">        name = value;</span>
<span class="fc" id="L106">    }</span>

    public void setAllocator (final CascadeAllocator value)
    {
<span class="fc" id="L110">        allocator = value;</span>
<span class="fc" id="L111">    }</span>

    public void addPump (final ConcretePump pump)
    {
<span class="fc" id="L115">        pumps.put(pump.name(), pump);</span>
<span class="fc" id="L116">    }</span>

    public void addReactor (final ConcreteReactor reactor)
    {
<span class="fc" id="L120">        reactors.put(reactor.name(), reactor);</span>
<span class="fc" id="L121">    }</span>

    @Override
    public CascadeToken name ()
    {
<span class="fc" id="L126">        return name;</span>
    }

    @Override
    public UUID uuid ()
    {
<span class="fc" id="L132">        return uuid;</span>
    }

    @Override
    public CascadeAllocator allocator ()
    {
<span class="fc" id="L138">        return allocator;</span>
    }

    @Override
    public SortedMap&lt;CascadeToken, CascadePump&gt; pumps ()
    {
<span class="fc" id="L144">        return unmodPumps;</span>
    }

    @Override
    public SortedMap&lt;CascadeToken, CascadeReactor&gt; reactors ()
    {
<span class="fc" id="L150">        return unmodReactors;</span>
    }

    @Override
    public ExecutionPhase phase ()
    {
<span class="fc" id="L156">        return ExecutionPhase.values()[phaseIdx.get()];</span>
    }

    @Override
    public Cascade start ()
    {
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (startWasCalled.compareAndSet(false, true))</span>
        {
<span class="nc" id="L164">            Verify.verify(phase().equals(ExecutionPhase.INITIAL));</span>
<span class="nc" id="L165">            performStartOnNewThread();</span>
        }

<span class="nc" id="L168">        return this;</span>
    }

    @Override
    public Cascade stop ()
    {
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (stopWasCalled.compareAndSet(false, true))</span>
        {
<span class="nc" id="L176">            performStopOnNewThread();</span>
        }

<span class="nc" id="L179">        return this;</span>
    }

    @Override
    public void await ()
            throws InterruptedException
    {
<span class="nc" id="L186">        awaitLatch.await();</span>
<span class="nc" id="L187">    }</span>

    @Override
    public String toString ()
    {
<span class="fc" id="L192">        return name.name();</span>
    }

    private void performStartOnNewThread ()
    {
<span class="nc" id="L197">        final String threadName = &quot;Cascade Startup Thread (&quot; + uuid() + &quot;)&quot;;</span>
<span class="nc" id="L198">        final Thread thread = new Thread(() -&gt; performStart(), threadName);</span>
<span class="nc" id="L199">        thread.setDaemon(false);</span>
<span class="nc" id="L200">        thread.start();</span>
<span class="nc" id="L201">    }</span>

    private void performStart ()
    {
        /**
         * We need to start the pumps first, so that any messages sent from within
         * the onSetup(*) and/or onStartup() event-handlers can at least be enqueued
         * for processing, even if the recipient reactors are not fully online yet.
         * Of course, this introduces the possibility that one of those event-handlers
         * will never return due to using a blocking send to a recipient that does
         * not have enough queue space available to store the incoming messages
         * pending startup; however, that would be a logic bug in the user program,
         * not something that we can reasonably deal with here.
         */
<span class="nc" id="L215">        startThePumps();</span>

        /**
         * Per the contract, bring each reactor online.
         */
<span class="nc" id="L220">        phaseIdx.incrementAndGet();</span>
<span class="nc" id="L221">        invokeSetupOnEachReactor();</span>

        /**
         * Per the contract, notify each reactor that the pumps have started
         * and all of the reactors have been brought online.
         */
<span class="nc" id="L227">        phaseIdx.incrementAndGet();</span>
<span class="nc" id="L228">        invokeStartOnEachReactor();</span>

        /**
         * The system is now running.
         */
<span class="nc" id="L233">        phaseIdx.incrementAndGet();</span>
<span class="nc" id="L234">        Verify.verify(phase().equals(ExecutionPhase.RUN));</span>

        /**
         * Stopping is now possible, since we have completely started.
         */
<span class="nc" id="L239">        stopLatch.countDown();</span>
<span class="nc" id="L240">    }</span>

    private void startThePumps ()
    {
<span class="nc" id="L244">        Verify.verify(phase().equals(ExecutionPhase.INITIAL));</span>

<span class="nc bnc" id="L246" title="All 2 branches missed.">        for (ConcretePump pump : pumps.values())</span>
        {
            try
            {
<span class="nc" id="L250">                pump.start();</span>
            }
<span class="nc" id="L252">            catch (Throwable ex)</span>
            {
                // Pass
<span class="nc" id="L255">            }</span>
<span class="nc" id="L256">        }</span>
<span class="nc" id="L257">    }</span>

    private void invokeSetupOnEachReactor ()
    {
<span class="nc" id="L261">        Verify.verify(phase().equals(ExecutionPhase.SETUP));</span>

<span class="nc bnc" id="L263" title="All 2 branches missed.">        for (CascadeReactor reactor : reactors.values())</span>
        {
<span class="nc" id="L265">            invokeEventHandler(reactor, ctx -&gt; reactor.core().onSetup(ctx));</span>
<span class="nc" id="L266">        }</span>
<span class="nc" id="L267">    }</span>

    private void invokeStartOnEachReactor ()
    {
<span class="nc" id="L271">        Verify.verify(phase().equals(ExecutionPhase.START));</span>

<span class="nc bnc" id="L273" title="All 2 branches missed.">        for (CascadeReactor reactor : reactors.values())</span>
        {
<span class="nc" id="L275">            invokeEventHandler(reactor, ctx -&gt; reactor.core().onStart(ctx));</span>
<span class="nc" id="L276">        }</span>
<span class="nc" id="L277">    }</span>

    private void performStopOnNewThread ()
    {
<span class="nc" id="L281">        final String threadName = &quot;Cascade Shutdown Thread (&quot; + uuid() + &quot;)&quot;;</span>
<span class="nc" id="L282">        final Thread thread = new Thread(() -&gt; performStop(), threadName);</span>
<span class="nc" id="L283">        thread.setDaemon(false);</span>
<span class="nc" id="L284">        thread.start();</span>
<span class="nc" id="L285">    }</span>

    private void performStop ()
    {
        /**
         * If the startup process is still in-progress,
         * then we cannot stop yet.
         */
<span class="nc" id="L293">        boolean allowed = false;</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">        while (allowed == false)</span>
        {
            try
            {
<span class="nc" id="L298">                stopLatch.await();</span>
<span class="nc" id="L299">                allowed = true;</span>
            }
<span class="nc" id="L301">            catch (InterruptedException ex)</span>
            {
<span class="nc" id="L303">                Thread.currentThread().interrupt(); // TODO: Correct???</span>
<span class="nc" id="L304">            }</span>
        }

        /**
         * Per the contract, inform each reactor that shutdown has begun.
         */
<span class="nc" id="L310">        phaseIdx.incrementAndGet();</span>
<span class="nc" id="L311">        invokeStopOnEachReactor();</span>

        /**
         * Per the contract, wait, indefinitely, for the reactors to shutdown.
         * If any of the reactors are buggy and fail to shutdown, then this call
         * will never return, which is out of our reasonable control.
         */
<span class="nc" id="L318">        waitForEachReactorToStop();</span>

        /**
         * Since the reactors are now shutdown, reactors (should) not be sending or
         * receiving anymore event-messages; therefore, we can now shutdown the pumps.
         */
<span class="nc" id="L324">        stopThePumps();</span>

        /**
         * Per the contract, notify each of the reactors that shutdown has occurred,
         * so that they can close/release any leak-able resources.
         */
<span class="nc" id="L330">        phaseIdx.incrementAndGet();</span>
<span class="nc" id="L331">        invokeDestroyOnEachReactor();</span>

        /**
         * The system is now shutdown.
         */
<span class="nc" id="L336">        phaseIdx.incrementAndGet();</span>
<span class="nc" id="L337">        Verify.verify(phase().equals(ExecutionPhase.TERMINATED));</span>

        /**
         * Stopping is now complete.
         */
<span class="nc" id="L342">        awaitLatch.countDown();</span>
<span class="nc" id="L343">    }</span>

    private void invokeStopOnEachReactor ()
    {
<span class="nc" id="L347">        Verify.verify(phase().equals(ExecutionPhase.STOP));</span>

<span class="nc bnc" id="L349" title="All 2 branches missed.">        for (CascadeReactor reactor : reactors.values())</span>
        {
<span class="nc" id="L351">            invokeEventHandler(reactor, ctx -&gt; reactor.core().onStop(ctx));</span>
<span class="nc" id="L352">        }</span>
<span class="nc" id="L353">    }</span>

    private void waitForEachReactorToStop ()
    {
<span class="nc" id="L357">        Verify.verify(phase().equals(ExecutionPhase.STOP));</span>

<span class="nc bnc" id="L359" title="All 2 branches missed.">        for (CascadeReactor reactor : reactors.values())</span>
        {
<span class="nc" id="L361">            final AtomicBoolean flag = new AtomicBoolean();</span>

<span class="nc bnc" id="L363" title="All 2 branches missed.">            while (flag.get() == false)</span>
            {
<span class="nc" id="L365">                invokeEventHandler(reactor, ctx -&gt; flag.set(reactor.core().isDestroyable()));</span>

                try
                {
<span class="nc" id="L369">                    Thread.sleep(250);</span>
                }
<span class="nc" id="L371">                catch (InterruptedException ex)</span>
                {
                    // Pass
<span class="nc" id="L374">                }</span>
            }
<span class="nc" id="L376">        }</span>
<span class="nc" id="L377">    }</span>

    private void stopThePumps ()
    {
<span class="nc" id="L381">        Verify.verify(phase().equals(ExecutionPhase.STOP));</span>

<span class="nc bnc" id="L383" title="All 2 branches missed.">        for (ConcretePump pump : pumps.values())</span>
        {
            try
            {
<span class="nc" id="L387">                pump.stop();</span>
            }
<span class="nc" id="L389">            catch (Throwable ex)</span>
            {
                // Pass
<span class="nc" id="L392">            }</span>
<span class="nc" id="L393">        }</span>
<span class="nc" id="L394">    }</span>

    private void invokeDestroyOnEachReactor ()
    {
<span class="nc" id="L398">        Verify.verify(phase().equals(ExecutionPhase.DESTROY));</span>

<span class="nc bnc" id="L400" title="All 2 branches missed.">        for (CascadeReactor reactor : reactors.values())</span>
        {
<span class="nc" id="L402">            invokeEventHandler(reactor, ctx -&gt; reactor.core().onDestroy(ctx));</span>
<span class="nc" id="L403">        }</span>
<span class="nc" id="L404">    }</span>

    private void invokeEventHandler (final CascadeReactor reactor,
                                     final Handler&lt;Context&gt; action)
    {
<span class="nc" id="L409">        final Thread currentThread = Thread.currentThread();</span>
<span class="nc" id="L410">        final ConcreteContext context = new ConcreteContext(reactor);</span>

        //try (OperandStack stack = new CheckedOperandStack(currentThread, allocator.newOperandStack())) // TODO
<span class="nc" id="L413">        try (OperandStack stack = allocator.newOperandStack())</span>
        {
            try

            {
<span class="nc" id="L418">                context.set(currentThread, null, stack, null);</span>
<span class="nc" id="L419">                action.accept(context);</span>
            }
<span class="nc" id="L421">            catch (Throwable ex1)</span>
            {
                try
                {
<span class="nc" id="L425">                    context.set(currentThread, null, stack, ex1);</span>
<span class="nc" id="L426">                    reactor.core().onException(context);</span>
                }
<span class="nc" id="L428">                catch (Throwable ex2)</span>
                {
                    // Pass
<span class="nc" id="L431">                }</span>
<span class="nc" id="L432">            }</span>
<span class="nc bnc" id="L433" title="All 8 branches missed.">        }</span>
<span class="nc" id="L434">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>