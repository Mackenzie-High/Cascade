<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConcretePump.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade.internal</a> &gt; <span class="el_source">ConcretePump.java</span></div><h1>ConcretePump.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade.internal;

import com.google.common.base.Verify;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.mackenziehigh.cascade.Cascade;
import com.mackenziehigh.cascade.CascadeAllocator.OperandStack;
import com.mackenziehigh.cascade.CascadePump;
import com.mackenziehigh.cascade.CascadeReactor;
import com.mackenziehigh.cascade.CascadeReactor.Core;
import com.mackenziehigh.cascade.CascadeToken;
import com.mackenziehigh.cascade.internal.Scheduler.TaskStream;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 *
 */
public final class ConcretePump
        implements CascadePump
{
<span class="fc" id="L28">    private final class ReactorInfo</span>
    {
        public ConcreteReactor reactor;

        public ConcreteContext context;

        public InflowQueue pipeline;

        public TaskStream&lt;ReactorInfo&gt; stream;
    }

    private final ConcreteCascade cascade;

    private final CascadeToken name;

    private final ImmutableSet&lt;Thread&gt; threads;

<span class="fc" id="L45">    private final AtomicBoolean stop = new AtomicBoolean();</span>

    private final ImmutableSet&lt;CascadeReactor&gt; reactors;

    private final Scheduler&lt;ReactorInfo&gt; scheduler;

<span class="fc" id="L51">    private final List&lt;ReactorInfo&gt; reactorInfos = Lists.newLinkedList();</span>

    public ConcretePump (final ConcreteCascade cascade,
                         final CascadeToken name,
                         final Collection&lt;ConcreteReactor&gt; reactors,
                         final ThreadFactory threadFactory,
                         final int threadCount)
<span class="fc" id="L58">    {</span>
<span class="fc" id="L59">        this.cascade = Objects.requireNonNull(cascade);</span>
<span class="fc" id="L60">        this.name = Objects.requireNonNull(name);</span>
<span class="fc" id="L61">        this.reactors = ImmutableSet.copyOf(reactors);</span>

        /**
         * Create the consumer threads.
         */
<span class="fc" id="L66">        final Set&lt;Thread&gt; threadsSet = Sets.newHashSet();</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">        for (int i = 0; i &lt; threadCount; i++)</span>
        {
<span class="pc" id="L69">            threadsSet.add(threadFactory.newThread(() -&gt; runTask()));</span>
        }
<span class="fc" id="L71">        this.threads = ImmutableSet.copyOf(threadsSet);</span>

        /**
         * Create the scheduler.
         */
<span class="fc bfc" id="L76" title="All 2 branches covered.">        for (ConcreteReactor reactor : reactors)</span>
        {
<span class="fc" id="L78">            final ReactorInfo info = new ReactorInfo();</span>
<span class="fc" id="L79">            info.reactor = reactor;</span>
<span class="fc" id="L80">            info.pipeline = reactor.input();</span>
<span class="fc" id="L81">            info.context = new ConcreteContext(reactor);</span>
<span class="fc" id="L82">            reactorInfos.add(info);</span>
<span class="fc" id="L83">        }</span>
<span class="fc" id="L84">        this.scheduler = new RoundRobinScheduler&lt;&gt;(reactorInfos);</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">        for (ReactorInfo info : scheduler.streams().keySet())</span>
        {
<span class="fc" id="L87">            info.stream = scheduler.streams().get(info);</span>
<span class="pc" id="L88">            info.pipeline.setCallback(x -&gt; scheduler.addTask(info.stream));</span>
<span class="fc" id="L89">            Verify.verifyNotNull(info.reactor);</span>
<span class="fc" id="L90">            Verify.verifyNotNull(info.pipeline);</span>
<span class="fc" id="L91">            Verify.verifyNotNull(info.context);</span>
<span class="fc" id="L92">            Verify.verifyNotNull(info.stream);</span>
<span class="fc" id="L93">        }</span>
<span class="fc" id="L94">    }</span>

    /**
     * Invariant Checking.
     */
    public void selfTest ()
    {
<span class="fc" id="L101">        Verify.verify(name().toString().equals(toString()));</span>
<span class="fc" id="L102">        Verify.verify(cascade().pumps().get(name()).equals(this));</span>

<span class="fc bfc" id="L104" title="All 2 branches covered.">        for (CascadeReactor reactor : reactors())</span>
        {
<span class="fc" id="L106">            Verify.verify(reactor.pump().equals(this));</span>
<span class="fc" id="L107">            Verify.verify(reactor.cascade().equals(cascade()));</span>
<span class="fc" id="L108">            Verify.verify(cascade().reactors().get(reactor.name()).equals(reactor));</span>
<span class="fc" id="L109">        }</span>
<span class="fc" id="L110">    }</span>

    @Override
    public Cascade cascade ()
    {
<span class="fc" id="L115">        return cascade;</span>
    }

    @Override
    public CascadeToken name ()
    {
<span class="fc" id="L121">        return name;</span>
    }

    @Override
    public Set&lt;Thread&gt; threads ()
    {
<span class="fc" id="L127">        return threads;</span>
    }

    @Override
    public Set&lt;CascadeReactor&gt; reactors ()
    {
<span class="fc" id="L133">        return reactors;</span>
    }

    @Override
    public String toString ()
    {
<span class="fc" id="L139">        return name.name();</span>
    }

    public void start ()
    {
<span class="nc" id="L144">        threads.forEach(x -&gt; x.start());</span>
<span class="nc" id="L145">    }</span>

    public void stop ()
    {
<span class="nc" id="L149">        stop.set(true);</span>
<span class="nc" id="L150">    }</span>

    private void runTask ()
    {
<span class="nc" id="L154">        final Thread currentThread = Thread.currentThread();</span>

        // TODO: try (OperandStack stack = new CheckedOperandStack(currentThread, cascade.allocator().newOperandStack()))
<span class="nc" id="L157">        try (OperandStack stack = cascade.allocator().newOperandStack())</span>
        {
<span class="nc" id="L159">            TaskStream&lt;ReactorInfo&gt; taskStream = null;</span>

<span class="nc bnc" id="L161" title="All 2 branches missed.">            while (stop.get() == false)</span>
            {
                try
                {
                    try
                    {
<span class="nc" id="L167">                        taskStream = scheduler.pollTask(1, TimeUnit.SECONDS);</span>
                    }
<span class="nc" id="L169">                    catch (InterruptedException ex)</span>
                    {
<span class="nc" id="L171">                        cascade().defaultLogger().warn(ex);</span>
<span class="nc" id="L172">                        Thread.currentThread().interrupt();</span>
                        continue;
<span class="nc" id="L174">                    }</span>

<span class="nc bnc" id="L176" title="All 2 branches missed.">                    if (taskStream == null)</span>
                    {
                        continue;
                    }

<span class="nc" id="L181">                    final CascadeToken event = taskStream.source().pipeline.poll(stack);</span>
<span class="nc" id="L182">                    final ConcreteContext context = taskStream.source().context;</span>
<span class="nc" id="L183">                    final Core core = taskStream.source().reactor.core();</span>

<span class="nc" id="L185">                    Verify.verifyNotNull(event);</span>
<span class="nc" id="L186">                    Verify.verifyNotNull(context);</span>
<span class="nc" id="L187">                    Verify.verifyNotNull(core);</span>

                    try
                    {
<span class="nc" id="L191">                        taskStream.source().reactor.enterCore();</span>
<span class="nc" id="L192">                        context.set(currentThread, event, stack, null);</span>
<span class="nc" id="L193">                        core.onMessage(context);</span>
                    }
<span class="nc" id="L195">                    catch (Throwable ex1)</span>
                    {
                        try
                        {
<span class="nc" id="L199">                            context.set(currentThread, event, stack, ex1);</span>
<span class="nc" id="L200">                            core.onException(context);</span>
                        }
<span class="nc" id="L202">                        catch (Throwable ex2)</span>
                        {
                            try
                            {
<span class="nc" id="L206">                                context.logger().warn(ex2);</span>
                            }
<span class="nc" id="L208">                            catch (Throwable ex3)</span>
                            {
                                try
                                {
<span class="nc" id="L212">                                    cascade().defaultLogger().warn(ex3);</span>
                                }
<span class="nc" id="L214">                                catch (Throwable ex4)</span>
                                {
<span class="nc" id="L216">                                    ex1.printStackTrace(System.err);</span>
<span class="nc" id="L217">                                    ex2.printStackTrace(System.err);</span>
<span class="nc" id="L218">                                    ex3.printStackTrace(System.err);</span>
<span class="nc" id="L219">                                    ex4.printStackTrace(System.err);</span>
<span class="nc" id="L220">                                }</span>
<span class="nc" id="L221">                            }</span>
<span class="nc" id="L222">                        }</span>
                    }
                    finally
                    {
<span class="nc" id="L226">                        context.set(currentThread, null, null, null);</span>
<span class="nc" id="L227">                        taskStream.source().reactor.exitCore();</span>
<span class="nc" id="L228">                    }</span>
                }
                finally
                {
<span class="nc bnc" id="L232" title="All 8 branches missed.">                    if (taskStream != null)</span>
                    {
<span class="nc" id="L234">                        taskStream.release();</span>
                    }
                }
            }
<span class="nc bnc" id="L238" title="All 8 branches missed.">        }</span>
<span class="nc" id="L239">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>