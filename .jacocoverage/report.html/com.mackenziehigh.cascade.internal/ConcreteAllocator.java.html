<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConcreteAllocator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade.internal</a> &gt; <span class="el_source">ConcreteAllocator.java</span></div><h1>ConcreteAllocator.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade.internal;

import com.google.common.base.Preconditions;
import com.google.common.base.Verify;
import com.mackenziehigh.cascade.Cascade;
import com.mackenziehigh.cascade.CascadeAllocator;
import com.mackenziehigh.cascade.CascadeToken;
import com.mackenziehigh.cascade.internal.PositiveIntRangeMap.RangeEntry;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.OptionalLong;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * Concrete Implementation Of: CascadeAllocator.
 */
public final class ConcreteAllocator
        implements CascadeAllocator
{

<span class="fc" id="L25">    private final CascadeAllocator ALLOCATOR = this;</span>

    private static final class StandardOperand
    {
        public final byte[] data;

        public final AllocationPool pool;

        public volatile int dataSize;

        public volatile StandardOperand below;

<span class="fc" id="L37">        public volatile int stackSize = 1;</span>

<span class="fc" id="L39">        private volatile long refCount = 0;</span>

        private final Consumer&lt;StandardOperand&gt; onFree;

        public StandardOperand (final AllocationPool pool,
                                final Consumer&lt;StandardOperand&gt; onFree,
                                final int capacity)
<span class="fc" id="L46">        {</span>
<span class="fc" id="L47">            this.pool = pool;</span>
<span class="fc" id="L48">            this.onFree = onFree;</span>
<span class="fc" id="L49">            this.data = new byte[capacity];</span>
<span class="fc" id="L50">        }</span>

        public synchronized void increment ()
        {
<span class="fc" id="L54">            ++refCount;</span>
<span class="fc" id="L55">        }</span>

        public synchronized void decrement ()
        {
<span class="fc" id="L59">            StandardOperand p = this;</span>
            StandardOperand next;

            /**
             * Walk down the spaghetti-stack, freeing operands,
             * until either no more frees are needed or the bottom
             * of the operand-stack is reached.
             */
<span class="fc bfc" id="L67" title="All 2 branches covered.">            while (p != null)</span>
            {
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">                Verify.verify(p != p.below);</span>

<span class="fc bfc" id="L71" title="All 2 branches covered.">                if (--p.refCount == 0)</span>
                {
<span class="fc" id="L73">                    next = p.below;</span>

                    // Free
<span class="fc" id="L76">                    p.below = null;</span>
<span class="fc" id="L77">                    p.dataSize = 0;</span>
<span class="fc" id="L78">                    p.stackSize = 0;</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">                    if (p.onFree != null)</span>
                    {
<span class="fc" id="L81">                        p.onFree.accept(p);</span>
                    }

<span class="fc" id="L84">                    p = next;</span>
                }
                else
                {
<span class="pc bpc" id="L88" title="1 of 4 branches missed.">                    Verify.verify(p.below == null || p.below.refCount &gt; 0);</span>
<span class="fc" id="L89">                    p = null;</span>
                }
            }
<span class="fc" id="L92">        }</span>

        public synchronized void init (final byte[] buffer,
                                       final int offset,
                                       final int length,
                                       final StandardOperand below)
        {
<span class="fc" id="L99">            this.refCount = 0;</span>
<span class="fc" id="L100">            this.dataSize = length;</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">            this.stackSize = (below == null ? 1 : below.stackSize + 1);</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">            Verify.verify(this != below);</span>
<span class="pc bpc" id="L103" title="1 of 4 branches missed.">            Verify.verify(0 != (below == null ? 1 : below.refCount));</span>
<span class="fc" id="L104">            this.below = below;</span>
<span class="fc" id="L105">            System.arraycopy(buffer, offset, this.data, 0, length);</span>

<span class="fc bfc" id="L107" title="All 2 branches covered.">            if (below != null)</span>
            {
<span class="fc" id="L109">                below.increment();</span>
            }
<span class="fc" id="L111">        }</span>
    }

    /**
     * Concrete Implementation Of: OperandStack.
     *
     * &lt;p&gt;
     * A unit-test is used to ensure that all of the methods herein are either
     * (final + synchronized) or (default), because OperandStack must be thread-safe.
     * &lt;/p&gt;
     */
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">    private final class StandardOperandStack</span>
            implements OperandStack
    {

<span class="fc" id="L126">        private volatile StandardOperand top = null;</span>

        public final synchronized void performSet (final StandardOperand operand)
        {
<span class="fc bfc" id="L130" title="All 4 branches covered.">            if (operand == null &amp;&amp; top == null)</span>
            {
<span class="fc" id="L132">                return;</span>
            }
<span class="pc bpc" id="L134" title="1 of 4 branches missed.">            else if (operand == null &amp;&amp; top != null)</span>
            {
<span class="fc" id="L136">                top.decrement();</span>
<span class="fc" id="L137">                top = null;</span>
<span class="fc" id="L138">                return;</span>
            }
<span class="pc bpc" id="L140" title="1 of 4 branches missed.">            else if (operand != null &amp;&amp; top == null)</span>
            {
<span class="fc" id="L142">                top = operand;</span>
<span class="fc" id="L143">                top.increment();</span>
<span class="fc" id="L144">                return;</span>
            }
            else // (operand != null &amp;&amp; top != null)
            {
<span class="pc bpc" id="L148" title="2 of 4 branches missed.">                assert operand != null;</span>
<span class="fc" id="L149">                final StandardOperand oldTop = top;</span>
<span class="fc" id="L150">                top = operand;</span>
<span class="fc" id="L151">                top.increment();</span>
<span class="fc" id="L152">                oldTop.decrement();</span>
<span class="fc" id="L153">                return;</span>
            }
        }

        @Override
        public final synchronized CascadeAllocator allocator ()
        {
<span class="fc" id="L160">            return ALLOCATOR;</span>
        }

        @Override
        public final synchronized AllocationPool pool ()
        {
<span class="fc bfc" id="L166" title="All 2 branches covered.">            return isStackEmpty() ? defaultPool() : top.pool;</span>
        }

        @Override
        public final synchronized OperandStack set (final OperandStack value)
        {

<span class="fc bfc" id="L173" title="All 4 branches covered.">            if (value == null || value.isStackEmpty())</span>
            {
<span class="fc" id="L175">                performSet(null);</span>
<span class="fc" id="L176">                return this;</span>
            }
<span class="fc bfc" id="L178" title="All 2 branches covered.">            else if (allocator().equals(value.allocator()) == false)</span>
            {
<span class="fc" id="L180">                throw new AllocatorMismatchException(allocator(), value.allocator());</span>
            }
            else
            {
<span class="fc" id="L184">                final StandardOperandStack other = (StandardOperandStack) value;</span>
<span class="fc" id="L185">                performSet(other.top);</span>
<span class="fc" id="L186">                return this;</span>
            }
        }

        @Override
        public final synchronized int operandSize ()
        {
<span class="fc bfc" id="L193" title="All 2 branches covered.">            return top == null ? 0 : top.dataSize;</span>
        }

        @Override
        public final synchronized int operandCapacity ()
        {
<span class="fc bfc" id="L199" title="All 2 branches covered.">            return top == null ? 0 : top.data.length;</span>
        }

        @Override
        public final synchronized int stackSize ()
        {
<span class="fc bfc" id="L205" title="All 2 branches covered.">            return top == null ? 0 : top.stackSize;</span>
        }

        @Override
        public final synchronized byte byteAt (final int index)
        {
<span class="fc bfc" id="L211" title="All 2 branches covered.">            if (isStackEmpty())</span>
            {
<span class="fc" id="L213">                throw new IllegalStateException(&quot;Empty Stack&quot;);</span>
            }
<span class="fc bfc" id="L215" title="All 4 branches covered.">            else if (index &lt; 0 || index &gt;= top.dataSize)</span>
            {
<span class="fc" id="L217">                throw new IndexOutOfBoundsException(String.format(&quot;index = %d, size = %d&quot;, index, top.dataSize));</span>
            }
            else
            {
<span class="fc" id="L221">                return top.data[index];</span>
            }
        }

        @Override
        public final synchronized OperandStack set (final OperandArray array,
                                                    final int index)
        {
<span class="fc bfc" id="L229" title="All 2 branches covered.">            if (array == null)</span>
            {
<span class="fc" id="L231">                throw new NullPointerException(&quot;array&quot;);</span>
            }
<span class="fc bfc" id="L233" title="All 2 branches covered.">            else if (allocator().equals(array.allocator()) == false)</span>
            {
<span class="fc" id="L235">                throw new AllocatorMismatchException(allocator(), array.allocator());</span>
            }
<span class="fc bfc" id="L237" title="All 2 branches covered.">            else if (index &lt; 0)</span>
            {
<span class="fc" id="L239">                throw new IndexOutOfBoundsException(&quot;index &lt; 0&quot;);</span>
            }
<span class="fc bfc" id="L241" title="All 2 branches covered.">            else if (index &gt;= array.size())</span>
            {
<span class="fc" id="L243">                throw new IndexOutOfBoundsException(&quot;index &gt;= array.length&quot;);</span>
            }
            else
            {
<span class="fc" id="L247">                final StandardOperand operand = ((StandardOperandArray) array).array[index];</span>
<span class="fc" id="L248">                performSet(operand);</span>
<span class="fc" id="L249">                return this;</span>
            }
        }

        @Override
        public final synchronized OperandStack push (final OperandStack value)
        {
<span class="fc bfc" id="L256" title="All 2 branches covered.">            if (value == null)</span>
            {
<span class="fc" id="L258">                throw new NullPointerException(&quot;value&quot;);</span>
            }
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">            else if (allocator().equals(value.allocator()) == false)</span>
            {
<span class="nc" id="L262">                throw new AllocatorMismatchException(allocator(), value.allocator());</span>
            }
<span class="fc bfc" id="L264" title="All 2 branches covered.">            else if (value.isStackEmpty())</span>
            {
<span class="fc" id="L266">                throw new IllegalArgumentException(&quot;Empty Stack&quot;);</span>
            }
            else
            {
<span class="fc" id="L270">                final StandardOperandStack other = ((StandardOperandStack) value);</span>
<span class="fc" id="L271">                return push(other.top.data, 0, value.operandSize());</span>
            }
        }

        @Override
        public final synchronized int copyTo (final byte[] buffer,
                                              final int offset,
                                              final int length)
        {
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">            if (isStackEmpty())</span>
            {
<span class="nc" id="L282">                throw new IllegalStateException(&quot;Empty Stack&quot;);</span>
            }
<span class="fc bfc" id="L284" title="All 2 branches covered.">            else if (buffer == null)</span>
            {
<span class="fc" id="L286">                throw new NullPointerException(&quot;buffer&quot;);</span>
            }
<span class="fc bfc" id="L288" title="All 2 branches covered.">            else if (offset &lt; 0)</span>
            {
<span class="fc" id="L290">                throw new IndexOutOfBoundsException(&quot;offset &lt; 0&quot;);</span>
            }
<span class="fc bfc" id="L292" title="All 2 branches covered.">            else if (offset &gt;= buffer.length)</span>
            {
<span class="fc" id="L294">                throw new IndexOutOfBoundsException(&quot;offset &gt;= buffer.length&quot;);</span>
            }
<span class="fc bfc" id="L296" title="All 2 branches covered.">            else if (offset + length &gt; buffer.length)</span>
            {
<span class="fc" id="L298">                throw new IllegalArgumentException(&quot;offset + length &gt;= buffer.length&quot;);</span>
            }
            else
            {
<span class="fc" id="L302">                System.arraycopy(top.data, 0, buffer, offset, length);</span>
<span class="fc" id="L303">                final int diff = buffer.length - offset;</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">                final int copied = diff &lt; length ? diff : length;</span>
<span class="fc" id="L305">                return copied;</span>
            }
        }

        @Override
        public final synchronized OperandStack pop ()
        {
<span class="fc bfc" id="L312" title="All 2 branches covered.">            if (isStackEmpty())</span>
            {
<span class="fc" id="L314">                throw new IllegalStateException(&quot;Empty Stack&quot;);</span>
            }
<span class="fc bfc" id="L316" title="All 2 branches covered.">            else if (stackSize() &gt; 1)</span>
            {
<span class="fc" id="L318">                final StandardOperand oldTop = top;</span>
<span class="fc" id="L319">                top = oldTop.below;</span>
<span class="fc" id="L320">                top.increment();</span>
<span class="fc" id="L321">                oldTop.decrement();</span>
<span class="fc" id="L322">                return this;</span>
            }
            else // stackSize() == 1
            {
<span class="fc" id="L326">                final StandardOperand oldTop = top;</span>
<span class="fc" id="L327">                top = null;</span>
<span class="fc" id="L328">                oldTop.decrement();</span>
<span class="fc" id="L329">                return this;</span>
            }
        }

    }

    private final class StandardOperandArray
            implements OperandArray
    {
        private final StandardOperand[] array;

        public StandardOperandArray (final int size)
<span class="fc" id="L341">        {</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">            Preconditions.checkArgument(size &gt;= 0, &quot;size &lt; 0&quot;);</span>
<span class="fc" id="L343">            this.array = new StandardOperand[size];</span>
<span class="fc" id="L344">        }</span>

        @Override
        public CascadeAllocator allocator ()
        {
<span class="fc" id="L349">            return ALLOCATOR;</span>
        }

        @Override
        public int size ()
        {
<span class="fc" id="L355">            return array.length;</span>
        }

        @Override
        public synchronized OperandArray set (final int index,
                                              final OperandStack value)
        {
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">            if (index &lt; 0)</span>
            {
<span class="nc" id="L364">                throw new IndexOutOfBoundsException(&quot;index &lt; 0&quot;);</span>
            }
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">            else if (index &gt;= array.length)</span>
            {
<span class="nc" id="L368">                throw new IndexOutOfBoundsException(&quot;index &gt;= array.length&quot;);</span>
            }
<span class="fc bfc" id="L370" title="All 4 branches covered.">            else if (value == null &amp;&amp; array[index] == null)</span>
            {
<span class="fc" id="L372">                return this;</span>
            }
<span class="pc bpc" id="L374" title="1 of 4 branches missed.">            else if (value == null &amp;&amp; array[index] != null)</span>
            {
<span class="fc" id="L376">                array[index].decrement();</span>
<span class="fc" id="L377">                array[index] = null;</span>
            }
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            else if (allocator().equals(value.allocator()) == false)</span>
            {
<span class="nc" id="L381">                throw new AllocatorMismatchException(allocator(), value.allocator());</span>
            }
<span class="fc bfc" id="L383" title="All 2 branches covered.">            else if (value.isStackEmpty())</span>
            {
<span class="fc" id="L385">                return set(index, null);</span>
            }
            else // value.isStackEmpty() == false
            {
<span class="fc" id="L389">                final StandardOperand operand = ((StandardOperandStack) value).top;</span>
<span class="fc" id="L390">                operand.increment();</span>
<span class="fc" id="L391">                array[index] = operand;</span>
            }

<span class="fc" id="L394">            return this;</span>
        }

        @Override
        public synchronized void close ()
        {
<span class="fc bfc" id="L400" title="All 2 branches covered.">            for (int i = 0; i &lt; array.length; i++)</span>
            {
<span class="fc" id="L402">                set(i, null);</span>
            }
<span class="fc" id="L404">        }</span>

    }

    /**
     * This class provides a concrete implementation of AllocationPool,
     * which allocates operands on-demand, rather than pre-allocating them.
     */
    public final class DynamicAllocationPool
            implements AllocationPool
    {
        private final CascadeToken name;

        private final int minimumSize;

        private final int maximumSize;

        public DynamicAllocationPool (final CascadeToken name,
                                      final int minimumSize,
                                      final int maximumSize)
<span class="fc" id="L424">        {</span>
<span class="fc" id="L425">            this.name = name;</span>
<span class="fc" id="L426">            this.minimumSize = minimumSize;</span>
<span class="fc" id="L427">            this.maximumSize = maximumSize;</span>
<span class="fc" id="L428">        }</span>

        @Override
        public CascadeToken name ()
        {
<span class="fc" id="L433">            return name;</span>
        }

        @Override
        public boolean isFixed ()
        {
<span class="fc" id="L439">            return false;</span>
        }

        @Override
        public int minimumAllocationSize ()
        {
<span class="fc" id="L445">            return minimumSize;</span>
        }

        @Override
        public int maximumAllocationSize ()
        {
<span class="fc" id="L451">            return maximumSize;</span>
        }

        @Override
        public CascadeAllocator allocator ()
        {
<span class="fc" id="L457">            return ALLOCATOR;</span>
        }

        @Override
        public boolean tryAlloc (final OperandStack stack,
                                 final byte[] buffer,
                                 final int offset,
                                 final int length)
        {
            try
            {
<span class="fc" id="L468">                checkAlloc(this, stack, buffer, offset, length);</span>
<span class="fc" id="L469">                final StandardOperandStack operands = (StandardOperandStack) stack;</span>
<span class="fc" id="L470">                final StandardOperand operand = new StandardOperand(this, null, length);</span>
<span class="fc" id="L471">                operand.init(buffer, offset, length, operands.top);</span>
<span class="fc" id="L472">                operands.performSet(operand);</span>
<span class="fc" id="L473">                return true;</span>
            }
<span class="nc" id="L475">            catch (OutOfMemoryError ex)</span>
            {
<span class="nc" id="L477">                return false;</span>
            }
        }
    }

    /**
     * This class provides a concrete implementation of AllocationPool,
     * which allocates operands using pre-allocated buffers.
     */
    public final class FixedAllocationPool
            implements AllocationPool
    {
        private final CascadeToken name;

        private final int minimumSize;

        private final int maximumSize;

        private final int capacity;

        private final ArrayBlockingQueue&lt;StandardOperand&gt; freePool;

        private final Consumer&lt;StandardOperand&gt; onFree;

        public FixedAllocationPool (final CascadeToken name,
                                    final int minimumSize,
                                    final int maximumSize,
                                    final int capacity)
<span class="fc" id="L505">        {</span>
<span class="fc" id="L506">            this.name = name;</span>
<span class="fc" id="L507">            this.minimumSize = minimumSize;</span>
<span class="fc" id="L508">            this.maximumSize = maximumSize;</span>
<span class="fc" id="L509">            this.capacity = capacity;</span>
<span class="fc" id="L510">            this.freePool = new ArrayBlockingQueue&lt;&gt;(capacity);</span>
<span class="fc" id="L511">            this.onFree = x -&gt; freePool.offer(x);</span>

<span class="fc bfc" id="L513" title="All 2 branches covered.">            for (int i = 0; i &lt; capacity; i++)</span>
            {
<span class="fc" id="L515">                freePool.offer(new StandardOperand(this, onFree, maximumSize));</span>
            }
<span class="fc" id="L517">        }</span>

        @Override
        public OptionalLong size ()
        {
<span class="fc" id="L522">            return OptionalLong.of(capacity - freePool.size());</span>
        }

        @Override
        public OptionalLong capacity ()
        {
<span class="fc" id="L528">            return OptionalLong.of(capacity);</span>
        }

        @Override
        public CascadeToken name ()
        {
<span class="fc" id="L534">            return name;</span>
        }

        @Override
        public boolean isFixed ()
        {
<span class="fc" id="L540">            return true;</span>
        }

        @Override
        public int minimumAllocationSize ()
        {
<span class="fc" id="L546">            return minimumSize;</span>
        }

        @Override
        public int maximumAllocationSize ()
        {
<span class="fc" id="L552">            return maximumSize;</span>
        }

        @Override
        public CascadeAllocator allocator ()
        {
<span class="fc" id="L558">            return ALLOCATOR;</span>
        }

        @Override
        public boolean tryAlloc (final OperandStack stack,
                                 final byte[] buffer,
                                 final int offset,
                                 final int length)
        {
<span class="fc" id="L567">            checkAlloc(this, stack, buffer, offset, length);</span>
<span class="fc" id="L568">            final StandardOperandStack operands = (StandardOperandStack) stack;</span>
<span class="fc" id="L569">            final StandardOperand operand = freePool.poll();</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">            if (operand == null)</span>
            {
<span class="fc" id="L572">                return false;</span>
            }
<span class="pc bpc" id="L574" title="1 of 4 branches missed.">            Verify.verify(operands.top == null || operands.top.refCount &gt;= 1);</span>
<span class="fc" id="L575">            operand.init(buffer, offset, length, operands.top);</span>
<span class="fc" id="L576">            operands.performSet(operand);</span>
<span class="fc" id="L577">            return true;</span>
        }

    }

    /**
     * This class provides a concrete implementation of AllocationPool,
     * which delegates to other pools based on a best-match policy.
     */
    public final class CompositeAllocationPool
            implements AllocationPool
    {
        private final CascadeToken name;

        private final int minimumSize;

        private final int maximumSize;

        private final AllocationPool fallback;

        /**
         * This object is used to select the best-matching delegate pool
         * based on the size of the requested allocation.
         */
        private final PositiveIntRangeMap&lt;AllocationPool&gt; lookup;

        public CompositeAllocationPool (final CascadeToken name,
                                        final AllocationPool fallback,
                                        final List&lt;AllocationPool&gt; pools)
<span class="fc" id="L606">        {</span>
<span class="fc" id="L607">            this.name = name;</span>

<span class="fc" id="L609">            this.fallback = fallback;</span>

<span class="fc bfc" id="L611" title="All 4 branches covered.">            final boolean none = fallback == null &amp;&amp; pools.isEmpty();</span>

<span class="fc bfc" id="L613" title="All 2 branches covered.">            final int min1 = fallback == null ? Integer.MAX_VALUE : fallback.minimumAllocationSize();</span>
<span class="fc" id="L614">            final int min2 = pools.stream().mapToInt(x -&gt; x.minimumAllocationSize()).min().orElse(min1);</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">            this.minimumSize = none ? 0 : Math.min(min1, min2);</span>

<span class="fc bfc" id="L617" title="All 2 branches covered.">            final int max1 = fallback == null ? Integer.MIN_VALUE : fallback.maximumAllocationSize();</span>
<span class="fc" id="L618">            final int max2 = pools.stream().mapToInt(x -&gt; x.maximumAllocationSize()).max().orElse(max1);</span>
<span class="fc bfc" id="L619" title="All 2 branches covered.">            this.maximumSize = none ? 0 : Math.max(max1, max2);</span>

<span class="fc" id="L621">            this.lookup = new PositiveIntRangeMap&lt;&gt;(pools.stream().map(x -&gt; new RangeEntry&lt;&gt;(x.minimumAllocationSize(), x.maximumAllocationSize(), x)).collect(Collectors.toList()));</span>
<span class="fc" id="L622">        }</span>

        @Override
        public CascadeToken name ()
        {
<span class="fc" id="L627">            return name;</span>
        }

        @Override
        public boolean isFixed ()
        {
<span class="fc" id="L633">            return false;</span>
        }

        @Override
        public int minimumAllocationSize ()
        {
<span class="fc" id="L639">            return minimumSize;</span>
        }

        @Override
        public int maximumAllocationSize ()
        {
<span class="fc" id="L645">            return maximumSize;</span>
        }

        @Override
        public CascadeAllocator allocator ()
        {
<span class="fc" id="L651">            return ALLOCATOR;</span>
        }

        @Override
        public boolean tryAlloc (final OperandStack stack,
                                 final byte[] buffer,
                                 final int offset,
                                 final int length)
        {
<span class="fc" id="L660">            checkAlloc(this, stack, buffer, offset, length);</span>
<span class="fc" id="L661">            final AllocationPool match = lookup.search(length);</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">            final AllocationPool pool = match == null ? fallback : match;</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">            if (pool == null)</span>
            {
<span class="nc" id="L665">                throw new IllegalArgumentException(&quot;No Applicable Delegate Pool&quot;);</span>
            }

<span class="fc" id="L668">            final boolean firstTry = pool.tryAlloc(stack, buffer, offset, length);</span>

<span class="fc bfc" id="L670" title="All 4 branches covered.">            if (firstTry == false &amp;&amp; fallback != null)</span>
            {
<span class="fc" id="L672">                return fallback.tryAlloc(stack, buffer, offset, length);</span>
            }
            else
            {
<span class="fc" id="L676">                return firstTry;</span>
            }
        }
    }

<span class="fc" id="L681">    private final CascadeToken DEFAULT = CascadeToken.create(&quot;default&quot;);</span>

    private Cascade cascade;

<span class="fc" id="L685">    private final Map&lt;CascadeToken, AllocationPool&gt; pools = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L687">    private final Map&lt;CascadeToken, AllocationPool&gt; unmodPools = Collections.unmodifiableMap(pools);</span>

    private volatile AllocationPool defaultPool;

    /**
     * Constructor, for testing purposes.
     */
    public ConcreteAllocator ()
    {
<span class="fc" id="L696">        this(null);</span>
<span class="fc" id="L697">    }</span>

    /**
     * Constructor, for production.
     *
     * @param owner owns this allocator.
     */
    public ConcreteAllocator (final Cascade owner)
<span class="fc" id="L705">    {</span>
<span class="fc" id="L706">        this.cascade = owner;</span>
<span class="fc" id="L707">    }</span>

    /**
     * Use this method to add a new dynamic allocation-pool to this allocator.
     *
     * &lt;p&gt;
     * This method should only be called during initial configuration.
     * &lt;/p&gt;
     *
     * @param name is the name of the new pool.
     * @param minimumSize is the minimum size of allocations in the pool.
     * @param maximumSize is the maximum size of allocations in the pool.
     * @return the new pool.
     */
    public AllocationPool addDynamicPool (final CascadeToken name,
                                          final int minimumSize,
                                          final int maximumSize)
    {
<span class="fc" id="L725">        final AllocationPool pool = new DynamicAllocationPool(name, minimumSize, maximumSize);</span>
<span class="fc" id="L726">        pools.put(name, pool);</span>
<span class="fc" id="L727">        return pool;</span>
    }

    /**
     * Use this method to add a new fixed-size allocation-pool to this allocator.
     *
     * &lt;p&gt;
     * This method should only be called during initial configuration.
     * &lt;/p&gt;
     *
     * @param name is the name of the new pool.
     * @param minimumSize is the minimum size of allocations in the pool.
     * @param maximumSize is the maximum size of allocations in the pool.
     * @param capacity is the maximum number of allocations in the pool at one time.
     * @return the new pool.
     */
    public AllocationPool addFixedPool (final CascadeToken name,
                                        final int minimumSize,
                                        final int maximumSize,
                                        final int capacity)
    {
<span class="fc" id="L748">        final AllocationPool pool = new FixedAllocationPool(name, minimumSize, maximumSize, capacity);</span>
<span class="fc" id="L749">        pools.put(name, pool);</span>
<span class="fc" id="L750">        return pool;</span>
    }

    /**
     * Use this method to add a new composite allocation-pool to this allocator.
     *
     * &lt;p&gt;
     * This method should only be called during initial configuration.
     * &lt;/p&gt;
     *
     * @param name is the name of the new pool.
     * @param fallback is the allocator to use, if none of the delegates are applicable.
     * @param delegates are the pools that the new pool will be composed of.
     * @return the new pool.
     */
    public AllocationPool addCompositePool (final CascadeToken name,
                                            final AllocationPool fallback,
                                            final List&lt;AllocationPool&gt; delegates)
    {
<span class="fc" id="L769">        final AllocationPool pool = new CompositeAllocationPool(name, fallback, delegates);</span>
<span class="fc" id="L770">        pools.put(name, pool);</span>
<span class="fc" id="L771">        return pool;</span>
    }

    @Override
    public Cascade cascade ()
    {
<span class="fc" id="L777">        return cascade;</span>
    }

    @Override
    public OperandStack newOperandStack ()
    {
<span class="fc" id="L783">        return new StandardOperandStack();</span>
    }

    @Override
    public OperandArray newOperandArray (final int size)
    {
<span class="fc" id="L789">        return new StandardOperandArray(size);</span>
    }

    @Override
    public Map&lt;CascadeToken, AllocationPool&gt; pools ()
    {
<span class="fc" id="L795">        return unmodPools;</span>
    }

    @Override
    public AllocationPool defaultPool ()
    {
<span class="fc bfc" id="L801" title="All 2 branches covered.">        if (defaultPool != null)</span>
        {
<span class="fc" id="L803">            return defaultPool;</span>
        }

<span class="fc" id="L806">        final AllocationPool pool = pools.get(DEFAULT);</span>

<span class="fc bfc" id="L808" title="All 2 branches covered.">        if (pool != null) // Depreciated, for old unit-tests only.</span>
        {
<span class="fc" id="L810">            return pool;</span>
        }
        else
        {
<span class="fc" id="L814">            throw new IllegalStateException(&quot;No Default Pool Exists&quot;);</span>
        }
    }

    public synchronized void setDefaultPool (final CascadeToken name)
    {
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">        Verify.verify(defaultPool == null);</span>
<span class="fc" id="L821">        defaultPool = pools.get(name);</span>
<span class="fc" id="L822">        Verify.verifyNotNull(defaultPool);</span>
<span class="fc" id="L823">    }</span>

    private void checkAlloc (final AllocationPool pool,
                             final OperandStack stack,
                             final byte[] buffer,
                             final int offset,
                             final int length)
    {

<span class="pc bpc" id="L832" title="1 of 2 branches missed.">        if (stack == null)</span>
        {
<span class="nc" id="L834">            throw new NullPointerException(&quot;stack&quot;);</span>
        }
<span class="fc bfc" id="L836" title="All 2 branches covered.">        else if (pool.allocator().equals(stack.allocator()) == false)</span>
        {
<span class="fc" id="L838">            throw new AllocatorMismatchException(pool.allocator(), stack.allocator());</span>
        }
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">        else if (buffer == null)</span>
        {
<span class="nc" id="L842">            throw new NullPointerException(&quot;buffer&quot;);</span>
        }
<span class="fc bfc" id="L844" title="All 2 branches covered.">        else if (offset &lt; 0)</span>
        {
<span class="fc" id="L846">            throw new IndexOutOfBoundsException(&quot;offset &lt; 0&quot;);</span>
        }
<span class="fc bfc" id="L848" title="All 4 branches covered.">        else if (offset &gt; 0 &amp;&amp; offset &gt;= buffer.length)</span>
        {
<span class="fc" id="L850">            throw new IndexOutOfBoundsException(&quot;offset &gt; 0 &amp;&amp; offset &gt;= buffer.length&quot;);</span>
        }
<span class="fc bfc" id="L852" title="All 2 branches covered.">        else if (length &lt; pool.minimumAllocationSize())</span>
        {
<span class="fc" id="L854">            throw new IllegalArgumentException(&quot;length &lt; minimumAllocationSize()&quot;);</span>
        }
<span class="pc bpc" id="L856" title="1 of 2 branches missed.">        else if (length &gt; pool.maximumAllocationSize())</span>
        {
<span class="nc" id="L858">            throw new IllegalArgumentException(&quot;length &gt; maximumAllocationSize()&quot;);</span>
        }
<span class="pc bpc" id="L860" title="1 of 4 branches missed.">        else if (offset &gt; 0 &amp;&amp; offset + length &gt;= buffer.length)</span>
        {
<span class="fc" id="L862">            throw new IllegalArgumentException(&quot;offset &gt; 0 &amp;&amp; offset + length &gt;= buffer.length&quot;);</span>
        }
<span class="fc bfc" id="L864" title="All 2 branches covered.">        else if (offset + length &gt; buffer.length)</span>
        {
<span class="fc" id="L866">            throw new IllegalArgumentException(&quot;offset + length &gt; buffer.length&quot;);</span>
        }
<span class="fc" id="L868">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>