<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FairScheduler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade.internal</a> &gt; <span class="el_source">FairScheduler.java</span></div><h1>FairScheduler.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade.internal;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Maps;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 *
 */
public final class FairScheduler&lt;T&gt;
        implements Scheduler&lt;T&gt;
{

<span class="fc" id="L19">    private final Map&lt;T, TaskStream&lt;T&gt;&gt; streams = Maps.newConcurrentMap();</span>

<span class="fc" id="L21">    private final Map&lt;T, TaskStream&lt;T&gt;&gt; unmodStreams = Collections.unmodifiableMap(streams);</span>

    private final BlockingQueue&lt;TaskStreamImp&gt; queue;

    public FairScheduler (final Collection&lt;T&gt; sources)
<span class="fc" id="L26">    {</span>
<span class="fc" id="L27">        sources.forEach(x -&gt; streams.put(x, new TaskStreamImp(x)));</span>
<span class="fc" id="L28">        queue = new ArrayBlockingQueue&lt;&gt;(sources.size() + 1);</span>
<span class="fc" id="L29">    }</span>

    @Override
    public Map&lt;T, TaskStream&lt;T&gt;&gt; streams ()
    {
<span class="fc" id="L34">        return unmodStreams;</span>
    }

    @Override
    public void addTask (final TaskStream&lt;T&gt; stream)
    {
<span class="nc" id="L40">        final TaskStreamImp tasker = (TaskStreamImp) stream;</span>
<span class="nc" id="L41">        tasker.addTask();</span>
<span class="nc" id="L42">    }</span>

    @Override
    public TaskStream&lt;T&gt; pollTask (final long timeout,
                                   final TimeUnit timeoutUnit)
            throws InterruptedException
    {
<span class="nc" id="L49">        final TaskStreamImp task = queue.poll(timeout, timeoutUnit);</span>
<span class="nc" id="L50">        return task;</span>
    }

    private final class TaskStreamImp
            implements TaskStream&lt;T&gt;
    {
        private final T source;

<span class="fc" id="L58">        private volatile boolean scheduled = false;</span>

<span class="fc" id="L60">        private volatile int count = 0;</span>

        public TaskStreamImp (final T src)
<span class="fc" id="L63">        {</span>
<span class="fc" id="L64">            this.source = src;</span>
<span class="fc" id="L65">        }</span>

        @Override
        public T source ()
        {
<span class="nc" id="L70">            return source;</span>
        }

        /**
         * This method is synchronized, which ensures that the addTask() method
         * cannot be invoked simultaneously on *this* particular task-stream.
         */
        @Override
        public synchronized void release ()
        {
<span class="nc" id="L80">            --count;</span>

<span class="nc bnc" id="L82" title="All 2 branches missed.">            if (count &lt; 0)</span>
            {
<span class="nc" id="L84">                throw new IllegalStateException(&quot;Too Many release() Calls = Bug!&quot;);</span>
            }
<span class="nc bnc" id="L86" title="All 2 branches missed.">            else if (count == 0)</span>
            {
                /**
                 * We do *not* need to add the task to the queue, anymore,
                 * until the producer thread adds another task to the stream,
                 * because there are no pending tasks.
                 */
<span class="nc" id="L93">                scheduled = false;</span>
            }
            else // count &gt; 0
            {
                /**
                 * Although one task has now been completed, more tasks are pending;
                 * therefore, we need to add this stream to the scheduling queue,
                 * so that the consumer threads can (eventually) process those tasks.
                 */
<span class="nc" id="L102">                queue.add(this);</span>
            }
<span class="nc" id="L104">        }</span>

        /**
         * This method is synchronized, which ensures that the release() method
         * cannot be invoked simultaneously on *this* particular task-stream.
         */
        public synchronized void addTask ()
        {
<span class="nc bnc" id="L112" title="All 2 branches missed.">            if (scheduled)</span>
            {
                /**
                 * Since the stream has already been scheduled,
                 * there are already tasks that are *either*
                 * enqueued or actively being processed.
                 * Therefore, we only want to increment the counter,
                 * because adding the stream to the scheduling queue
                 * now could result in two consumer threads processing
                 * messages from the same stream simultaneously,
                 * which would be contractually inappropriate.
                 */
<span class="nc" id="L124">                ++count;</span>
            }
            else
            {
                /**
                 * Until this flag is set to false, the release()
                 * and pollTask() methods will be responsible for
                 * adding and removing this task-stream to/from
                 * the scheduling queue.
                 */
<span class="nc" id="L134">                scheduled = true;</span>
<span class="nc" id="L135">                ++count;</span>
<span class="nc" id="L136">                queue.add(this);</span>
            }
<span class="nc" id="L138">        }</span>
    }

    public static void main (String[] args)
            throws InterruptedException
    {
<span class="nc" id="L144">        final FairScheduler&lt;String&gt; sch = new FairScheduler&lt;&gt;(ImmutableList.of(&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;));</span>

<span class="nc" id="L146">        sch.addTask(sch.streams().get(&quot;X&quot;));</span>
<span class="nc" id="L147">        sch.addTask(sch.streams().get(&quot;X&quot;));</span>

<span class="nc" id="L149">        System.out.println(sch.pollTask(1, TimeUnit.HOURS));</span>
<span class="nc" id="L150">        sch.streams().get(&quot;X&quot;).release();</span>
<span class="nc" id="L151">        System.out.println(sch.pollTask(1, TimeUnit.HOURS));</span>
<span class="nc" id="L152">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>