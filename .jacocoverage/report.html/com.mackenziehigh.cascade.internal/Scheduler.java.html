<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Scheduler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade.internal</a> &gt; <span class="el_source">Scheduler.java</span></div><h1>Scheduler.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade.internal;

import java.util.Comparator;
import java.util.Objects;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

/**
 * Prioritized Least-Recently-Used based Scheduler.
 *
 * @param &lt;E&gt;
 */
public final class Scheduler&lt;E&gt;
{
    /**
     * These are the processes that are currently *awaiting* execution.
     *
     * &lt;p&gt;
     * This queue does *not* contain any duplicates.
     * If a single Process is scheduled multiple times,
     * while it is awaiting or undergoing execution,
     * then a counter in the Process will be incremented.
     * This avoids unnecessary wastage of space in this queue.
     * Otherwise, in the context of scheduling actors,
     * this queue could grow to equal the sum of the sizes
     * of the inflow-queues of the scheduled actors.
     * &lt;/p&gt;
     */
<span class="fc" id="L32">    public final BlockingQueue&lt;Process&lt;E&gt;&gt; scheduled = new PriorityBlockingQueue&lt;&gt;(32, Comparator.naturalOrder());</span>

<span class="fc" id="L34">    private final AtomicLong globalSequenceNumber = new AtomicLong();</span>

<span class="fc" id="L36">    private final Object lock = new Object();</span>

    private final Runnable callback;

    /**
     * Sole constructor.
     *
     * @param callback will be invoked in order to signal that work is available.
     */
    public Scheduler (final Runnable callback)
<span class="fc" id="L46">    {</span>
<span class="fc" id="L47">        this.callback = Objects.requireNonNull(callback, &quot;callback&quot;);</span>
<span class="fc" id="L48">    }</span>

    /**
     * Use this method to define a new process that can
     * be scheduled for execution using this scheduler.
     *
     * @return the newly defined process.
     */
    public Process&lt;E&gt; newProcess ()
    {
<span class="fc" id="L58">        return new Process(this);</span>
    }

    /**
     * Use this method to retrieve and remove the Process that needs executed next.
     *
     * @return the next scheduled Process, or null, if none is immediately available.
     */
    public Process&lt;E&gt; poll ()
    {
<span class="fc" id="L68">        final Process&lt;E&gt; next = scheduled.poll();</span>
<span class="fc" id="L69">        return next;</span>
    }

    /**
     * A Process represents an executable entity that can
     * be scheduled for execution using a Scheduler object.
     *
     * @param &lt;T&gt;
     */
    public static final class Process&lt;T&gt;
            implements AutoCloseable,
                       Comparable&lt;Process&lt;T&gt;&gt;
    {
        /**
         * This means something to the user of the Scheduler,
         * but not to us here, we just need to hold onto it.
         */
<span class="fc" id="L86">        private final AtomicReference&lt;T&gt; userObject = new AtomicReference&lt;&gt;();</span>

        /**
         * This is the Scheduler that is able to schedule this Process.
         */
        private final Scheduler owner;

        /**
         * This counter is incremented every time that this Process is executed.
         */
<span class="fc" id="L96">        private final AtomicLong sequenceNumber = new AtomicLong();</span>

        /**
         * This flag is true, when this Process is currently being
         * executed or is currently enqueued awaiting execution.
         * Inversely, this flag is false when this Process is
         * neither being executed nor awaiting execution.
         */
<span class="fc" id="L104">        private final AtomicBoolean active = new AtomicBoolean();</span>

        /**
         * This is the number of pending executions of this Process
         * that have yet to be performed. Only one reference to
         * this Process object will be enqueued in the Scheduler
         * queue at any one time. If this Process is scheduled
         * while it is enqueued pending execution, then this
         * counter will simply be incremented, which is more
         * efficient than placing multiple entries into
         * the Scheduler queue.
         */
<span class="fc" id="L116">        private final AtomicLong pendingExecutionCount = new AtomicLong();</span>

        private Process (final Scheduler owner)
<span class="fc" id="L119">        {</span>
<span class="fc" id="L120">            this.owner = Objects.requireNonNull(owner, &quot;owner&quot;);</span>
<span class="fc" id="L121">        }</span>

        /**
         * Getter.
         *
         * @return the user-specified object corresponding to this Process.
         */
        public AtomicReference&lt;T&gt; userObject ()
        {
<span class="fc" id="L130">            return userObject;</span>
        }

        /**
         * Use this method to cause this Process to be scheduled for execution.
         */
        public void schedule ()
        {
<span class="fc" id="L138">            synchronized (owner.lock)</span>
            {
<span class="fc" id="L140">                pendingExecutionCount.incrementAndGet();</span>

<span class="fc bfc" id="L142" title="All 2 branches covered.">                if (active.compareAndSet(false, true))</span>
                {
<span class="fc" id="L144">                    owner.scheduled.add(this);</span>
<span class="fc" id="L145">                    owner.callback.run();</span>
                }
<span class="pc" id="L147">            }</span>
<span class="fc" id="L148">        }</span>

        /**
         * Invoke this method after executing this Process
         * in order to notify the Scheduler that this Process
         * is no longer currently being executed.
         */
        @Override
        public void close ()
        {
<span class="fc" id="L158">            synchronized (owner.lock)</span>
            {
<span class="fc" id="L160">                sequenceNumber.set(owner.globalSequenceNumber.incrementAndGet());</span>

<span class="fc bfc" id="L162" title="All 2 branches covered.">                if (pendingExecutionCount.decrementAndGet() &gt; 0)</span>
                {
<span class="fc" id="L164">                    active.set(true);</span>
<span class="fc" id="L165">                    owner.scheduled.add(this);</span>
<span class="fc" id="L166">                    owner.callback.run();</span>
                }
                else
                {
<span class="fc" id="L170">                    active.set(false);</span>
                }
<span class="pc" id="L172">            }</span>
<span class="fc" id="L173">        }</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public int compareTo (final Process&lt;T&gt; other)
        {
<span class="fc" id="L181">            return Long.compare(sequenceNumber.get(), other.sequenceNumber.get());</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>