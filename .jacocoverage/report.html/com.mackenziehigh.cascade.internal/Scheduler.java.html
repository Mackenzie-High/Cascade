<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Scheduler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade.internal</a> &gt; <span class="el_source">Scheduler.java</span></div><h1>Scheduler.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade.internal;

import com.google.common.base.Verify;
import java.util.Comparator;
import java.util.Objects;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.PriorityBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Prioritized Least-Recently-Used based Scheduler.
 *
 * @param &lt;E&gt;
 */
<span class="nc" id="L17">public final class Scheduler&lt;E&gt;</span>
{
    /**
     * These are the processes that are currently *awaiting* execution.
     *
     * &lt;p&gt;
     * This queue does *not* contain any duplicates.
     * If a single Process is scheduled multiple times,
     * while it is awaiting or undergoing execution,
     * then a counter in the Process will be incremented.
     * This avoids unnecessary wastage of space.
     * &lt;/p&gt;
     */
<span class="nc" id="L30">    private final BlockingQueue&lt;Process&lt;E&gt;&gt; scheduled = new PriorityBlockingQueue&lt;&gt;(32, Comparator.reverseOrder());</span>

<span class="nc" id="L32">    private final Object lock = new Object();</span>

    /**
     * Use this method to define a new process that can
     * be scheduled for execution using this scheduler.
     *
     * @param priority will be the priority of the new process.
     * @param userObject a user-defined object to associate with the new process.
     * @return the newly defined process.
     */
    public Process&lt;E&gt; newProcess (final int priority,
                                  final E userObject)
    {
<span class="nc bnc" id="L45" title="All 2 branches missed.">        if (priority &lt; 0)</span>
        {
<span class="nc" id="L47">            throw new IllegalArgumentException(&quot;priority &lt; 0&quot;);</span>
        }
        else
        {
<span class="nc" id="L51">            return new Process(this, priority, userObject);</span>
        }
    }

    /**
     * Use this method to retrieve and remove the Process that needs executed next,
     * blocking if necessary, for a Process to become available.
     *
     * @param timeout is the maximum number of milliseconds to wait.
     * @return the next scheduled Process, or null, if the timeout occurred.
     * @throws InterruptedException if an interruption occurs while waiting.
     */
    public Process&lt;E&gt; poll (final long timeout)
            throws InterruptedException
    {
<span class="nc bnc" id="L66" title="All 2 branches missed.">        if (timeout &lt; 1)</span>
        {
<span class="nc" id="L68">            throw new IllegalArgumentException(&quot;timeout &lt; 1&quot;);</span>
        }
        else
        {

<span class="nc" id="L73">            final Process&lt;E&gt; next = scheduled.poll(timeout, TimeUnit.MILLISECONDS);</span>
<span class="nc bnc" id="L74" title="All 4 branches missed.">            Verify.verify(next == null || next.locked.get());</span>
<span class="nc" id="L75">            return next;</span>
        }
    }

    /**
     * A Process represents an executable entity that can
     * be scheduled for execution using a Scheduler object.
     *
     * @param &lt;T&gt;
     */
    public static final class Process&lt;T&gt;
            implements AutoCloseable,
                       Comparable&lt;Process&lt;T&gt;&gt;
    {
        /**
         * This means something to the user of the Scheduler,
         * but not to us here, we just need to hold it.
         */
        private final T userObject;

        /**
         * This is the Scheduler that is able to schedule this Process.
         */
        private final Scheduler owner;

        /**
         * This is the priority with which the Scheduler will treat
         * this Process relative to other Processes.
         *
         * &lt;p&gt;
         * Larger numbers equal higher priorities.
         * &lt;/p&gt;
         */
        private final int priority;

        /**
         * This counter is incremented every time that this Process is executed.
         */
<span class="nc" id="L113">        private final AtomicLong sequenceNumber = new AtomicLong();</span>

        /**
         * This flag is true, when this Process is currently being executed.
         */
<span class="nc" id="L118">        private final AtomicBoolean locked = new AtomicBoolean();</span>

        /**
         * This is the number of pending executions of this Process
         * that have yet to be performed. Only one reference to
         * this Process object will be enqueued in the Scheduler
         * queue at any one time. If this Process is scheduled
         * while it is enqueued pending execution, then this
         * counter will simply be incremented, which is more
         * efficient than placing multiple entries into
         * the Scheduler queue.
         */
<span class="nc" id="L130">        private final AtomicLong pendingExecutionCount = new AtomicLong();</span>

        private Process (final Scheduler owner,
                         final int priority,
                         final T userObject)
<span class="nc" id="L135">        {</span>
<span class="nc" id="L136">            this.owner = Objects.requireNonNull(owner, &quot;owner&quot;);</span>
<span class="nc" id="L137">            this.priority = priority;</span>
<span class="nc" id="L138">            this.userObject = Objects.requireNonNull(userObject, &quot;userObject&quot;);</span>
<span class="nc" id="L139">        }</span>

        /**
         * Getter.
         *
         * @return the user-specified object corresponding to this Process.
         */
        public T getUserObject ()
        {
<span class="nc" id="L148">            return userObject;</span>
        }

        /**
         * Use this method to cause this Process to be scheduled for execution.
         */
        public void schedule ()
        {
<span class="nc" id="L156">            synchronized (owner.lock)</span>
            {
<span class="nc bnc" id="L158" title="All 2 branches missed.">                if (locked.compareAndSet(false, true))</span>
                {
<span class="nc" id="L160">                    owner.scheduled.add(this);</span>
                }
                else
                {
<span class="nc" id="L164">                    pendingExecutionCount.incrementAndGet();</span>
                }
<span class="nc" id="L166">            }</span>
<span class="nc" id="L167">        }</span>

        /**
         * Invoke this method after executing this Process
         * in order to notify the Scheduler that this Process
         * is no longer currently being executed.
         */
        @Override
        public void close ()
        {
<span class="nc" id="L177">            synchronized (owner.lock)</span>
            {
<span class="nc" id="L179">                sequenceNumber.incrementAndGet();</span>

<span class="nc bnc" id="L181" title="All 2 branches missed.">                if (pendingExecutionCount.get() &gt; 0)</span>
                {
<span class="nc" id="L183">                    pendingExecutionCount.decrementAndGet();</span>
<span class="nc" id="L184">                    locked.set(true);</span>
<span class="nc" id="L185">                    owner.scheduled.add(this);</span>
                }
                else
                {
<span class="nc" id="L189">                    pendingExecutionCount.set(0);</span>
<span class="nc" id="L190">                    locked.set(false);</span>
                }
<span class="nc" id="L192">            }</span>
<span class="nc" id="L193">        }</span>

        /**
         * {@inheritDoc}
         */
        @Override
        public int compareTo (final Process&lt;T&gt; other)
        {
<span class="nc bnc" id="L201" title="All 2 branches missed.">            if (priority != other.priority)</span>
            {
<span class="nc" id="L203">                return Integer.compare(priority, other.priority);</span>
            }
<span class="nc bnc" id="L205" title="All 2 branches missed.">            else if (sequenceNumber.get() &gt; other.sequenceNumber.get())</span>
            {
<span class="nc" id="L207">                return -1; // Higher Seq Num == Lower Priority</span>
            }
<span class="nc bnc" id="L209" title="All 2 branches missed.">            else if (sequenceNumber.get() &lt; other.sequenceNumber.get())</span>
            {
<span class="nc" id="L211">                return +1; // Lower Seq Num == Higher Priority</span>
            }
            else
            {
<span class="nc" id="L215">                return 0;</span>
            }
        }
    }

    public static void main (String[] args)
            throws InterruptedException
    {
<span class="nc" id="L223">        final Scheduler&lt;String&gt; ss = new Scheduler&lt;&gt;();</span>

<span class="nc" id="L225">        ss.newProcess(0, &quot;A&quot;).schedule();</span>
<span class="nc" id="L226">        ss.newProcess(1, &quot;B&quot;).schedule();</span>

        while (true)
        {
<span class="nc" id="L230">            final Process&lt;String&gt; ps = ss.poll(1000L);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if (ps != null)</span>
            {
<span class="nc" id="L233">                try (Process cs = ps)</span>
                {
<span class="nc" id="L235">                    System.out.println(&quot;X = &quot; + cs.getUserObject());</span>
<span class="nc bnc" id="L236" title="All 8 branches missed.">                }</span>
            }
<span class="nc" id="L238">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>