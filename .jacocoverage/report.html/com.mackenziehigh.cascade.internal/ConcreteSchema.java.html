<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConcreteSchema.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade.internal</a> &gt; <span class="el_source">ConcreteSchema.java</span></div><h1>ConcreteSchema.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade.internal;

import com.google.common.base.Preconditions;
import com.google.common.base.Verify;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.LinkedListMultimap;
import com.google.common.collect.Maps;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.mackenziehigh.cascade.Cascade;
import com.mackenziehigh.cascade.CascadeAllocator.AllocationPool;
import com.mackenziehigh.cascade.CascadeLogger;
import com.mackenziehigh.cascade.CascadeReactor;
import com.mackenziehigh.cascade.CascadeReactor.Core;
import com.mackenziehigh.cascade.CascadeSchema;
import com.mackenziehigh.cascade.CascadeToken;
import com.mackenziehigh.cascade.internal.EventDispatcher.ConcurrentEventSender;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.concurrent.ThreadFactory;
import java.util.stream.Collectors;

/**
 * TODO: The user must always specify a default pool.
 */
public final class ConcreteSchema
        implements CascadeSchema
{
    // TODO: Set uncaught exception handler
<span class="fc" id="L34">    private final ThreadFactory defaultThreadFactory = new ThreadFactoryBuilder().setDaemon(false).build();</span>

    /**
     * This is the name() of the Cascade object being built.
     */
    private final CascadeToken name;

    /**
     * This contains the &quot;using&quot; settings for the current namespace.
     */
<span class="fc" id="L44">    private final Scope scope = new Scope();</span>

    /**
     * There are the names of all of the pools that have been added thus far.
     */
<span class="fc" id="L49">    private final Set&lt;CascadeToken&gt; declaredPools = Sets.newHashSet();</span>

    /**
     * There are the names of all of the pumps that have been added thus far.
     */
<span class="fc" id="L54">    private final Set&lt;CascadeToken&gt; declaredPumps = Sets.newHashSet();</span>

    /**
     * There are the names of all of the reactors that have been added thus far.
     */
<span class="fc" id="L59">    private final Set&lt;CascadeToken&gt; declaredReactors = Sets.newHashSet();</span>

    /**
     * This map maps the name of an allocation-pool to the corresponding configuration.
     */
<span class="fc" id="L64">    private final Map&lt;CascadeToken, DynamicPoolSchemaImp&gt; dynamicPools = Maps.newHashMap();</span>

    /**
     * This map maps the name of an allocation-pool to the corresponding configuration.
     */
<span class="fc" id="L69">    private final Map&lt;CascadeToken, FixedPoolSchemaImp&gt; fixedPools = Maps.newHashMap();</span>

    /**
     * This map maps the name of an allocation-pool to the corresponding configuration.
     */
<span class="fc" id="L74">    private final Map&lt;CascadeToken, CompositePoolSchemaImp&gt; compositePools = Maps.newHashMap();</span>

    /**
     * This map maps the name of a pump to the corresponding configuration.
     */
<span class="fc" id="L79">    private final Map&lt;CascadeToken, PumpSchemaImp&gt; pumps = Maps.newHashMap();</span>

    /**
     * This map maps the name of a reactor to the corresponding configuration.
     */
<span class="fc" id="L84">    private final Map&lt;CascadeToken, ReactorSchemaImp&gt; reactors = Maps.newHashMap();</span>

    /**
     * Eventually, this map will map the name of a pool to the pool itself.
     */
<span class="fc" id="L89">    private final Map&lt;CascadeToken, AllocationPool&gt; namesToPools = Maps.newHashMap();</span>

    /**
     * Eventually, this map will map the name of a pump to the pump itself.
     */
<span class="fc" id="L94">    private final Map&lt;CascadeToken, ConcretePump&gt; namesToPumps = Maps.newHashMap();</span>

    /**
     * Eventually, this map will map the name of a reactor to the reactor itself.
     */
<span class="fc" id="L99">    private final Multimap&lt;CascadeToken, ConcreteReactor&gt; pumpsToReactors = LinkedListMultimap.create();</span>

    /**
     * This map maps the name of a reactor to the corresponding queue
     * that will be used to store pending event-messages that are
     * flowing into that particular reactor.
     */
<span class="fc" id="L106">    private final Map&lt;CascadeToken, InflowQueue&gt; reactorsToQueues = Maps.newConcurrentMap();</span>

    /**
     * At runtime, this object will route event-messages to
     * the reactors that subscribed to those event-messages.
     */
    private EventDispatcher dispatcher;

    /**
     * This is the schema that describes the global default allocation-pool,
     * if the user explicitly specified such a pool.
     */
    private CascadeToken defaultPool;

    /**
     * This is the object that is being built/configured by this schema.
     */
<span class="fc" id="L123">    private final ConcreteCascade cascade = new ConcreteCascade();</span>

    /**
     * This is the allocator() of the Cascade object.
     */
<span class="fc" id="L128">    private final ConcreteAllocator allocator = new ConcreteAllocator(cascade);</span>

    /**
     * This is used to prevent build() from being called again.
     */
    private boolean built;

    /**
     * Sole constructor.
     *
     * @param name will be the name of the cascade object.
     */
    public ConcreteSchema (final String name)
<span class="fc" id="L141">    {</span>
<span class="fc" id="L142">        this.name = CascadeToken.create(name);</span>
<span class="fc" id="L143">        resetScope();</span>
<span class="fc" id="L144">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public CascadeSchema enter (final String name)
    {
<span class="fc" id="L152">        Preconditions.checkNotNull(name, &quot;name&quot;);</span>
<span class="fc" id="L153">        final CascadeToken token = CascadeToken.create(name);</span>
<span class="fc" id="L154">        resetScope();</span>
<span class="fc" id="L155">        scope.namespace = token;</span>
<span class="fc" id="L156">        return this;</span>
    }

    private void resetScope ()
    {
<span class="fc" id="L161">        scope.logger = site -&gt; new StandardLogger(site);</span>
<span class="fc" id="L162">        scope.pool = null;</span>
<span class="fc" id="L163">        scope.pump = null;</span>
<span class="fc" id="L164">        scope.queueType = QueueType.LINKED;</span>
<span class="fc" id="L165">        scope.queueCapacity = Integer.MAX_VALUE;</span>
<span class="fc" id="L166">    }</span>

    private void requireNamespace ()
    {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (scope.namespace == null)</span>
        {
<span class="nc" id="L172">            throw new IllegalStateException(&quot;No namespace was specified!&quot;);</span>
        }
<span class="fc" id="L174">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public CascadeSchema usingLogger (final CascadeLogger.Factory factory)
    {
<span class="fc" id="L182">        Preconditions.checkNotNull(factory, &quot;factory&quot;);</span>
<span class="fc" id="L183">        requireNamespace();</span>
<span class="fc" id="L184">        scope.logger = factory;</span>
<span class="fc" id="L185">        return this;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CascadeSchema usingPool (final String name)
    {
<span class="fc" id="L194">        requireNamespace();</span>
<span class="fc" id="L195">        scope.pool = convertName(name);</span>
<span class="fc" id="L196">        return this;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CascadeSchema usingPump (final String name)
    {
<span class="fc" id="L205">        requireNamespace();</span>
<span class="fc" id="L206">        scope.pump = convertName(name);</span>
<span class="fc" id="L207">        return this;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CascadeSchema usingLinkedQueues (final int capacity)
    {
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        Preconditions.checkArgument(capacity &gt;= 0, &quot;capacity &lt; 0&quot;);</span>
<span class="fc" id="L217">        requireNamespace();</span>
<span class="fc" id="L218">        scope.queueType = QueueType.LINKED;</span>
<span class="fc" id="L219">        scope.queueCapacity = capacity;</span>
<span class="fc" id="L220">        return this;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CascadeSchema usingArrayQueues (final int capacity)
    {
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">        Preconditions.checkArgument(capacity &gt;= 0, &quot;capacity &lt; 0&quot;);</span>
<span class="fc" id="L230">        requireNamespace();</span>
<span class="fc" id="L231">        scope.queueType = QueueType.ARRAY;</span>
<span class="fc" id="L232">        scope.queueCapacity = capacity;</span>
<span class="fc" id="L233">        return this;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public DynamicPoolSchema addDynamicPool (final String name)
    {
<span class="fc" id="L242">        requireNamespace();</span>
<span class="fc" id="L243">        final DynamicPoolSchemaImp result = new DynamicPoolSchemaImp();</span>
<span class="fc" id="L244">        result.name = convertName(name);</span>
<span class="fc" id="L245">        dynamicPools.put(result.name, result);</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        require(name, &quot;Duplicate Dynamic Pool&quot;, !declaredPools.contains(result.name));</span>
<span class="fc" id="L247">        declaredPools.add(result.name);</span>
<span class="fc" id="L248">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public FixedPoolSchema addFixedPool (final String name)
    {
<span class="fc" id="L257">        requireNamespace();</span>
<span class="fc" id="L258">        final FixedPoolSchemaImp result = new FixedPoolSchemaImp();</span>
<span class="fc" id="L259">        result.name = convertName(name);</span>
<span class="fc" id="L260">        fixedPools.put(result.name, result);</span>
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        require(name, &quot;Duplicate Fixed Pool&quot;, !declaredPools.contains(result.name));</span>
<span class="fc" id="L262">        declaredPools.add(result.name);</span>
<span class="fc" id="L263">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CompositePoolSchema addCompositePool (final String name)
    {
<span class="fc" id="L272">        requireNamespace();</span>
<span class="fc" id="L273">        final CompositePoolSchemaImp result = new CompositePoolSchemaImp();</span>
<span class="fc" id="L274">        result.name = convertName(name);</span>
<span class="fc" id="L275">        compositePools.put(result.name, result);</span>
<span class="pc bpc" id="L276" title="1 of 2 branches missed.">        require(name, &quot;Duplicate Composite Pool&quot;, !declaredPools.contains(result.name));</span>
<span class="fc" id="L277">        declaredPools.add(result.name);</span>
<span class="fc" id="L278">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public PumpSchema addPump (final String name)
    {
<span class="fc" id="L287">        requireNamespace();</span>
<span class="fc" id="L288">        final PumpSchemaImp result = new PumpSchemaImp();</span>
<span class="fc" id="L289">        result.name = convertName(name);</span>
<span class="fc" id="L290">        pumps.put(result.name, result);</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        require(name, &quot;Duplicate Pump&quot;, !declaredPumps.contains(result.name));</span>
<span class="fc" id="L292">        declaredPumps.add(result.name);</span>
<span class="fc" id="L293">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ReactorSchema addReactor (final String name)
    {
<span class="fc" id="L302">        requireNamespace();</span>
<span class="fc" id="L303">        final ReactorSchemaImp result = new ReactorSchemaImp();</span>
<span class="fc" id="L304">        result.name = convertName(name);</span>
<span class="fc" id="L305">        result.logger = scope.logger.create(result.name);</span>
<span class="fc" id="L306">        result.pool = scope.pool;</span>
<span class="fc" id="L307">        result.pump = scope.pump;</span>
<span class="fc" id="L308">        result.queueType = scope.queueType;</span>
<span class="fc" id="L309">        result.queueCapacity = scope.queueCapacity;</span>
<span class="fc" id="L310">        reactors.put(result.name, result);</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        require(name, &quot;Duplicate Reactor&quot;, !declaredReactors.contains(result.name));</span>
<span class="fc" id="L312">        declaredPools.add(result.name);</span>

        /**
         * Create a default queue, which may get replaced.
         */
<span class="fc bfc" id="L317" title="All 2 branches covered.">        result.queue = scope.queueType == QueueType.ARRAY</span>
<span class="fc" id="L318">                ? new ArrayInflowQueue(allocator, scope.queueCapacity)</span>
<span class="fc" id="L319">                : new LinkedInflowQueue(allocator, scope.queueCapacity);</span>

<span class="fc" id="L321">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Cascade build ()
    {
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">        if (built)</span>
        {
<span class="nc" id="L332">            throw new IllegalStateException(&quot;build() was already called once!&quot;);</span>
        }
        else
        {
<span class="fc" id="L336">            built = true;</span>
        }

        /**
         * The user must specify a default allocation-pool.
         */
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (defaultPool == null)</span>
        {
<span class="fc" id="L344">            throw new IllegalStateException(&quot;No default allocation-pool was specified!&quot;);</span>
        }

        /**
         * The user must specify at least one pump.
         */
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (declaredPumps.isEmpty())</span>
        {
<span class="fc" id="L352">            throw new IllegalStateException(&quot;No pumps were specified!&quot;);</span>
        }

        /**
         * Global.
         */
<span class="fc" id="L358">        cascade.setName(name);</span>
<span class="fc" id="L359">        cascade.setAllocator(allocator);</span>

        /**
         * Validate.
         */
<span class="fc" id="L364">        dynamicPools.values().forEach(x -&gt; validate(x));</span>
<span class="fc" id="L365">        fixedPools.values().forEach(x -&gt; validate(x));</span>
<span class="fc" id="L366">        compositePools.values().forEach(x -&gt; validate(x));</span>
<span class="fc" id="L367">        pumps.values().forEach(x -&gt; validate(x));</span>
<span class="fc" id="L368">        reactors.values().forEach(x -&gt; validate(x));</span>

        /**
         * Create the routing-table.
         */
<span class="fc" id="L373">        reactors.values().forEach(x -&gt; reactorsToQueues.put(x.name, x.queue));</span>
<span class="fc" id="L374">        dispatcher = new EventDispatcher(reactorsToQueues);</span>
<span class="fc" id="L375">        reactors.values().forEach(s -&gt; s.subscriptions.forEach(e -&gt; dispatcher.register(s.name, e)));</span>

        /**
         * Compile - Pass #1.
         */
<span class="fc" id="L380">        dynamicPools.values().forEach(x -&gt; compile1(x));</span>
<span class="fc" id="L381">        fixedPools.values().forEach(x -&gt; compile1(x));</span>
<span class="fc" id="L382">        compositePools.values().forEach(x -&gt; compile1(x));</span>

        /**
         * Compile - Pass #2.
         */
<span class="fc" id="L387">        reactors.values().forEach(x -&gt; compile2(x));</span>

        /**
         * Compile - Pass #3.
         */
<span class="fc" id="L392">        pumps.values().forEach(x -&gt; compile3(x));</span>

        /**
         * Global.
         */
<span class="fc" id="L397">        pumps.values().forEach(x -&gt; cascade.addPump(x.pump));</span>
<span class="fc" id="L398">        reactors.values().forEach(x -&gt; cascade.addReactor(x.reactor));</span>
<span class="fc" id="L399">        allocator.setDefaultPool(defaultPool);</span>

        /**
         * Verify.
         */
<span class="fc" id="L404">        verifyCascade();</span>
<span class="fc" id="L405">        dynamicPools.values().forEach(x -&gt; verify(x));</span>
<span class="fc" id="L406">        fixedPools.values().forEach(x -&gt; verify(x));</span>
<span class="fc" id="L407">        compositePools.values().forEach(x -&gt; verify(x));</span>
<span class="fc" id="L408">        pumps.values().forEach(x -&gt; verify(x));</span>
<span class="fc" id="L409">        reactors.values().forEach(x -&gt; verify(x));</span>

        /**
         * Verify - Self Tests.
         */
<span class="fc" id="L414">        cascade.selfTest();</span>
<span class="fc" id="L415">        pumps.values().forEach(x -&gt; x.pump.selfTest());</span>
<span class="fc" id="L416">        reactors.values().forEach(x -&gt; x.reactor.selfTest());</span>

<span class="fc" id="L418">        return cascade;</span>
    }

    private void validate (final DynamicPoolSchemaImp object)
    {
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Dynamic Pool: Unspecified Minimum Size&quot;, object.minimumSize != null);</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Dynamic Pool: Unspecified Maximum Size&quot;, object.maximumSize != null);</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Dynamic Pool: Minimum Size &lt; 0&quot;, object.minimumSize &gt;= 0);</span>
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Dynamic Pool: Maximum Size &lt; 0&quot;, object.maximumSize &gt;= 0);</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Dynamic Pool: Minimum Size &gt; Maximum Size&quot;, object.minimumSize &lt;= object.maximumSize);</span>
<span class="fc" id="L428">    }</span>

    private void validate (final FixedPoolSchemaImp object)
    {
<span class="fc bfc" id="L432" title="All 2 branches covered.">        require(object.name.name(), &quot;Fixed Pool: Unspecified Minimum Size&quot;, object.minimumSize != null);</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">        require(object.name.name(), &quot;Fixed Pool: Unspecified Maximum Size&quot;, object.maximumSize != null);</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">        require(object.name.name(), &quot;Fixed Pool: Unspecified Buffer Count&quot;, object.bufferCount != null);</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Fixed Pool: Minimum Size &lt; 0&quot;, object.minimumSize &gt;= 0);</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Fixed Pool: Maximum Size &lt; 0&quot;, object.maximumSize &gt;= 0);</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Fixed Pool: Buffer Count &lt; 0&quot;, object.bufferCount &gt;= 0);</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Fixed Pool: Minimum Size &gt; Maximum Size&quot;, object.minimumSize &lt;= object.maximumSize);</span>
<span class="fc" id="L439">    }</span>

    private void validate (final CompositePoolSchemaImp object)
    {
        /**
         * The fallback pool must exist.
         */
<span class="fc bfc" id="L446" title="All 2 branches covered.">        if (object.fallback != null)</span>
        {
<span class="fc" id="L448">            require(object.name.name(), &quot;Composite Pool: No Such Fallback Pool (&quot; + object.fallback + &quot;)&quot;, declaredPools.contains(object.fallback));</span>
        }

        /**
         * All of the member pools must exist.
         */
<span class="fc" id="L454">        object.members.forEach(x -&gt; require(object.name.name(), &quot;Composite Pool: No Such Member Pool (&quot; + x + &quot;)&quot;, declaredPools.contains(x)));</span>

        /**
         * The fallback-pool cannot be a composite-pool.
         */
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (object.fallback != null)</span>
        {
<span class="fc bfc" id="L461" title="All 2 branches covered.">            require(object.name.name(), &quot;Composite Pool: Composite Fallback Pool (&quot; + object.fallback + &quot;)&quot;, !compositePools.containsKey(object.fallback));</span>
        }

        /**
         * The member-pools cannot be composite-pools.
         */
<span class="fc bfc" id="L467" title="All 2 branches covered.">        object.members.forEach(x -&gt; require(object.name.name(), &quot;Composite Pool: Composite Member Pool (&quot; + x + &quot;)&quot;, !compositePools.containsKey(x)));</span>
<span class="fc" id="L468">    }</span>

    private void validate (final PumpSchemaImp object)
    {
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Pump: Unspecified Name&quot;, object.name != null);</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Pump: Unspecified Thread Count&quot;, object.threadCount != null);</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Pump: Thread Count &lt; 0&quot;, object.threadCount &gt;= 0);</span>
<span class="fc" id="L475">    }</span>

    private void validate (final ReactorSchemaImp object)
    {
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Reactor: Unspecified Name&quot;, object.name != null);</span>
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Reactor: Unspecified Logger&quot;, object.logger != null);</span>
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Reactor: Unspecified Allocation Pool&quot;, object.pool != null);</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Reactor: Unspecified Pump&quot;, object.pump != null);</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Reactor: Unspecified Core&quot;, object.core != null);</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">        require(object.name.name(), &quot;Reactor: Unspecified Queue Type&quot;, object.queueType != null);</span>
<span class="fc" id="L485">    }</span>

    private void compile1 (final DynamicPoolSchemaImp object)
    {
<span class="fc" id="L489">        object.pool = allocator.addDynamicPool(object.name,</span>
<span class="fc" id="L490">                                               object.minimumSize,</span>
<span class="fc" id="L491">                                               object.maximumSize);</span>

<span class="fc" id="L493">        namesToPools.put(object.name, object.pool);</span>
<span class="fc" id="L494">    }</span>

    private void compile1 (final FixedPoolSchemaImp object)
    {
<span class="fc" id="L498">        object.pool = allocator.addFixedPool(object.name,</span>
<span class="fc" id="L499">                                             object.minimumSize,</span>
<span class="fc" id="L500">                                             object.maximumSize,</span>
<span class="fc" id="L501">                                             object.bufferCount);</span>

<span class="fc" id="L503">        namesToPools.put(object.name, object.pool);</span>
<span class="fc" id="L504">    }</span>

    private void compile1 (final CompositePoolSchemaImp object)
    {
<span class="fc bfc" id="L508" title="All 2 branches covered.">        final AllocationPool fallback = object.fallback == null ? null : allocator.pools().get(object.fallback);</span>
<span class="fc" id="L509">        final List&lt;AllocationPool&gt; delegates = object.members.stream().map(x -&gt; allocator.pools().get(x)).collect(Collectors.toList());</span>
<span class="fc" id="L510">        object.pool = allocator.addCompositePool(object.name, fallback, delegates);</span>
<span class="fc" id="L511">        namesToPools.put(object.name, object.pool);</span>
<span class="fc" id="L512">    }</span>

    private void compile2 (final ReactorSchemaImp object)
    {
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">        Verify.verify(object.name != null);</span>
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">        Verify.verify(object.core != null);</span>
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">        Verify.verify(object.pool != null);</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">        Verify.verify(object.logger != null);</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">        Verify.verify(object.queue != null);</span>

<span class="fc" id="L522">        final ConcurrentEventSender sender = dispatcher.lookup(object.name);</span>

<span class="fc" id="L524">        final AllocationPool pool = allocator.pools().get(object.pool);</span>

<span class="fc" id="L526">        object.reactor = new ConcreteReactor(cascade,</span>
                                             object.name,
                                             object.core,
                                             pool,
                                             object.pump,
                                             object.logger,
<span class="fc" id="L532">                                             ImmutableMap.of(), // TODO</span>
                                             object.queue,
                                             sender);

<span class="fc" id="L536">        pumpsToReactors.put(object.pump, object.reactor);</span>
<span class="fc" id="L537">    }</span>

    private void compile3 (final PumpSchemaImp object)
    {
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">        final ThreadFactory factory = object.threadFactory != null ? object.threadFactory : defaultThreadFactory;</span>

<span class="fc" id="L543">        object.pump = new ConcretePump(cascade,</span>
                                       object.name,
<span class="fc" id="L545">                                       pumpsToReactors.get(object.name),</span>
                                       factory,
<span class="fc" id="L547">                                       object.threadCount);</span>

<span class="fc" id="L549">        namesToPumps.put(object.pump.name(), object.pump);</span>
<span class="fc" id="L550">    }</span>

    private void verifyCascade ()
    {
<span class="fc" id="L554">        Verify.verifyNotNull(cascade.name());</span>
<span class="fc" id="L555">        Verify.verifyNotNull(cascade.uuid());</span>
<span class="fc" id="L556">        Verify.verifyNotNull(cascade.allocator());</span>
<span class="fc" id="L557">        Verify.verifyNotNull(cascade.phase());</span>
<span class="fc" id="L558">        Verify.verifyNotNull(cascade.pumps());</span>
<span class="fc" id="L559">        Verify.verifyNotNull(cascade.reactors());</span>
<span class="fc" id="L560">        Verify.verify(cascade.name().equals(name));</span>
<span class="fc" id="L561">        Verify.verify(cascade.name().toString().equals(cascade.toString()));</span>
<span class="fc" id="L562">        Verify.verify(cascade.name().name().equals(cascade.toString()));</span>
<span class="fc" id="L563">        Verify.verify(cascade.phase().equals(Cascade.ExecutionPhase.INITIAL));</span>
<span class="fc" id="L564">    }</span>

    private void verify (final DynamicPoolSchemaImp object)
    {
<span class="fc" id="L568">        Verify.verifyNotNull(object.pool);</span>
<span class="fc" id="L569">        Verify.verifyNotNull(object.name);</span>
<span class="fc" id="L570">        Verify.verifyNotNull(object.minimumSize);</span>
<span class="fc" id="L571">        Verify.verifyNotNull(object.maximumSize);</span>
<span class="pc bpc" id="L572" title="1 of 2 branches missed.">        Verify.verify(object.minimumSize &gt;= 0);</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">        Verify.verify(object.maximumSize &gt;= 0);</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">        Verify.verify(object.minimumSize &lt;= object.maximumSize);</span>
<span class="fc" id="L575">        Verify.verify(object.pool.name().equals(object.name));</span>
<span class="fc" id="L576">        Verify.verify(object.minimumSize.equals(object.pool.minimumAllocationSize()));</span>
<span class="fc" id="L577">        Verify.verify(object.maximumSize.equals(object.pool.maximumAllocationSize()));</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">        Verify.verify(object.pool.isFixed() == false);</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">        Verify.verify(object.pool.size().isPresent() == false);</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">        Verify.verify(object.pool.capacity().isPresent() == false);</span>
<span class="fc" id="L581">        Verify.verify(object.pool.allocator().equals(cascade.allocator()));</span>
<span class="fc" id="L582">        Verify.verify(cascade.allocator().pools().get(object.name).equals(object.pool));</span>
<span class="fc" id="L583">        Verify.verify(cascade.equals(object.pool.allocator().cascade()));</span>
<span class="fc" id="L584">    }</span>

    private void verify (final FixedPoolSchemaImp object)
    {
<span class="fc" id="L588">        Verify.verifyNotNull(object.pool);</span>
<span class="fc" id="L589">        Verify.verifyNotNull(object.name);</span>
<span class="fc" id="L590">        Verify.verifyNotNull(object.minimumSize);</span>
<span class="fc" id="L591">        Verify.verifyNotNull(object.maximumSize);</span>
<span class="fc" id="L592">        Verify.verifyNotNull(object.bufferCount);</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">        Verify.verify(object.minimumSize &gt;= 0);</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">        Verify.verify(object.maximumSize &gt;= 0);</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">        Verify.verify(object.minimumSize &lt;= object.maximumSize);</span>
<span class="pc bpc" id="L596" title="1 of 2 branches missed.">        Verify.verify(object.bufferCount &gt;= 0);</span>
<span class="fc" id="L597">        Verify.verify(object.pool.name().equals(object.name));</span>
<span class="fc" id="L598">        Verify.verify(object.minimumSize.equals(object.pool.minimumAllocationSize()));</span>
<span class="fc" id="L599">        Verify.verify(object.maximumSize.equals(object.pool.maximumAllocationSize()));</span>
<span class="fc" id="L600">        Verify.verify(object.pool.isFixed());</span>
<span class="fc" id="L601">        Verify.verify(object.pool.size().isPresent());</span>
<span class="fc" id="L602">        Verify.verify(object.pool.capacity().isPresent());</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">        Verify.verify(object.pool.size().getAsLong() == 0);</span>
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">        Verify.verify(object.pool.capacity().getAsLong() == object.bufferCount);</span>
<span class="fc" id="L605">        Verify.verify(object.pool.allocator().equals(cascade.allocator()));</span>
<span class="fc" id="L606">        Verify.verify(cascade.allocator().pools().get(object.name).equals(object.pool));</span>
<span class="fc" id="L607">        Verify.verify(cascade.equals(object.pool.allocator().cascade()));</span>
<span class="fc" id="L608">    }</span>

    private void verify (final CompositePoolSchemaImp object)
    {
<span class="fc" id="L612">        Verify.verifyNotNull(object.pool);</span>
<span class="fc" id="L613">        Verify.verifyNotNull(object.name);</span>
<span class="fc" id="L614">        Verify.verify(object.pool.name().equals(object.name));</span>
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">        Verify.verify(object.pool.size().isPresent() == false);</span>
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">        Verify.verify(object.pool.capacity().isPresent() == false);</span>
<span class="fc" id="L617">        Verify.verify(object.pool.allocator().equals(cascade.allocator()));</span>
<span class="fc" id="L618">        Verify.verify(cascade.allocator().pools().get(object.name).equals(object.pool));</span>
<span class="fc" id="L619">        Verify.verify(cascade.equals(object.pool.allocator().cascade()));</span>
<span class="fc" id="L620">    }</span>

    private void verify (final PumpSchemaImp object)
    {
<span class="fc" id="L624">        Verify.verifyNotNull(object.pump);</span>
<span class="fc" id="L625">        Verify.verifyNotNull(object.name);</span>
<span class="fc" id="L626">        Verify.verifyNotNull(object.threadCount);</span>
<span class="fc" id="L627">        Verify.verify(cascade.equals(object.pump.cascade()));</span>
<span class="fc" id="L628">        Verify.verify(object.pump.name().equals(object.name));</span>
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">        Verify.verify(object.pump.threads().size() == object.threadCount);</span>
<span class="fc" id="L630">        Verify.verify(cascade.pumps().get(object.name).equals(object.pump));</span>
<span class="fc" id="L631">    }</span>

    private void verify (final ReactorSchemaImp object)
    {
<span class="fc" id="L635">        Verify.verifyNotNull(object.reactor);</span>
<span class="fc" id="L636">        Verify.verifyNotNull(object.core);</span>
<span class="fc" id="L637">        Verify.verifyNotNull(object.name);</span>
<span class="fc" id="L638">        Verify.verifyNotNull(object.queueType);</span>
<span class="fc" id="L639">        Verify.verifyNotNull(object.queueCapacity);</span>
<span class="fc" id="L640">        Verify.verifyNotNull(object.queue);</span>
<span class="fc" id="L641">        Verify.verifyNotNull(object.logger);</span>
<span class="fc" id="L642">        Verify.verifyNotNull(object.pool);</span>
<span class="fc" id="L643">        Verify.verifyNotNull(object.pump);</span>
<span class="fc" id="L644">        Verify.verify(cascade.equals(object.reactor.cascade()));</span>
<span class="fc" id="L645">        Verify.verify(object.reactor.name().equals(object.name));</span>
<span class="fc" id="L646">        Verify.verify(object.reactor.allocator().equals(cascade.allocator()));</span>
<span class="fc" id="L647">        Verify.verify(object.reactor.pool().name().equals(object.pool));</span>
<span class="fc" id="L648">        Verify.verify(object.reactor.core().equals(object.core));</span>
<span class="fc" id="L649">        Verify.verify(object.reactor.input().equals(object.queue));</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">        Verify.verify(object.reactor.queueCapacity() == object.queueCapacity);</span>
<span class="fc" id="L651">        Verify.verifyNotNull(object.reactor.logger());</span>
<span class="fc" id="L652">        Verify.verify(object.reactor.pump().name().equals(object.pump));</span>
<span class="fc" id="L653">        Verify.verify(cascade.pumps().get(object.reactor.pump().name()).equals(object.reactor.pump()));</span>
<span class="fc" id="L654">        Verify.verify(cascade.reactors().get(object.reactor.name()).equals(object.reactor));</span>
<span class="fc" id="L655">        Verify.verify(object.reactor.pump().reactors().contains(object.reactor));</span>
<span class="fc" id="L656">    }</span>

    private void require (final String site,
                          final String message,
                          final boolean condition)
    {
<span class="fc bfc" id="L662" title="All 2 branches covered.">        if (condition == false)</span>
        {
<span class="fc" id="L664">            throw new RuntimeException(&quot;(&quot; + site + &quot;) &quot; + message);</span>
        }
<span class="fc" id="L666">    }</span>

    private CascadeToken convertName (final String name)
    {
<span class="fc" id="L670">        Preconditions.checkNotNull(name, &quot;name&quot;);</span>

<span class="fc" id="L672">        final CascadeToken token = CascadeToken.create(name);</span>

<span class="pc bpc" id="L674" title="1 of 4 branches missed.">        if (token.isSimpleName() &amp;&amp; scope.namespace != null)</span>
        {
<span class="fc" id="L676">            return scope.namespace.append(name);</span>
        }
        else
        {
<span class="fc" id="L680">            return token;</span>
        }
    }

<span class="fc" id="L684">    private final class DynamicPoolSchemaImp</span>
            implements DynamicPoolSchema
    {
        public CascadeToken name;

<span class="fc" id="L689">        public Integer minimumSize = 0;</span>

<span class="fc" id="L691">        public Integer maximumSize = Integer.MAX_VALUE;</span>

        public AllocationPool pool;

        @Override
        public DynamicPoolSchema withMinimumSize (final int bound)
        {
<span class="fc" id="L698">            this.minimumSize = bound;</span>
<span class="fc" id="L699">            return this;</span>
        }

        @Override
        public DynamicPoolSchema withMaximumSize (final int bound)
        {
<span class="fc" id="L705">            this.maximumSize = bound;</span>
<span class="fc" id="L706">            return this;</span>
        }

        @Override
        public DynamicPoolSchema makeGlobalDefault ()
        {
<span class="fc" id="L712">            defaultPool = name;</span>
<span class="fc" id="L713">            return this;</span>
        }
    };

<span class="fc" id="L717">    private final class FixedPoolSchemaImp</span>
            implements FixedPoolSchema
    {
        public CascadeToken name;

        public Integer minimumSize;

        public Integer maximumSize;

        public Integer bufferCount;

        public AllocationPool pool;

        @Override
        public FixedPoolSchema withMinimumSize (final int bound)
        {
<span class="fc" id="L733">            this.minimumSize = bound;</span>
<span class="fc" id="L734">            return this;</span>
        }

        @Override
        public FixedPoolSchema withMaximumSize (final int bound)
        {
<span class="fc" id="L740">            this.maximumSize = bound;</span>
<span class="fc" id="L741">            return this;</span>
        }

        @Override
        public FixedPoolSchema withBufferCount (final int count)
        {
<span class="fc" id="L747">            this.bufferCount = count;</span>
<span class="fc" id="L748">            return this;</span>
        }

        @Override
        public FixedPoolSchema makeGlobalDefault ()
        {
<span class="fc" id="L754">            defaultPool = name;</span>
<span class="fc" id="L755">            return this;</span>
        }

    };

<span class="fc" id="L760">    private final class CompositePoolSchemaImp</span>
            implements CompositePoolSchema
    {
        public CascadeToken name;

        public CascadeToken fallback;

<span class="fc" id="L767">        public final Set&lt;CascadeToken&gt; members = Sets.newHashSet();</span>

        public AllocationPool pool;

        @Override
        public CompositePoolSchema withFallbackPool (final String name)
        {
<span class="fc" id="L774">            final CascadeToken token = convertName(name);</span>
<span class="fc" id="L775">            this.fallback = token;</span>
<span class="fc" id="L776">            return this;</span>
        }

        @Override
        public CompositePoolSchema withMemberPool (final String name)
        {
<span class="fc" id="L782">            final CascadeToken member = convertName(name);</span>
<span class="fc" id="L783">            members.add(member);</span>
<span class="fc" id="L784">            return this;</span>
        }

        @Override
        public CompositePoolSchema makeGlobalDefault ()
        {
<span class="fc" id="L790">            defaultPool = name;</span>
<span class="fc" id="L791">            return this;</span>
        }

    };

<span class="fc" id="L796">    private final class PumpSchemaImp</span>
            implements PumpSchema
    {

        public CascadeToken name;

<span class="fc" id="L802">        public ThreadFactory threadFactory = defaultThreadFactory;</span>

<span class="fc" id="L804">        public Integer threadCount = 1;</span>

        public ConcretePump pump;

        @Override
        public PumpSchema usingThreadFactory (final ThreadFactory factory)
        {
<span class="fc" id="L811">            this.threadFactory = factory;</span>
<span class="fc" id="L812">            return this;</span>
        }

        @Override
        public PumpSchema withThreadCount (final int count)
        {
<span class="fc" id="L818">            this.threadCount = count;</span>
<span class="fc" id="L819">            return this;</span>
        }

    };

<span class="pc" id="L824">    private enum QueueType</span>
    {
<span class="fc" id="L826">        ARRAY,</span>
<span class="fc" id="L827">        LINKED,</span>
    }

<span class="fc" id="L830">    private final class ReactorSchemaImp</span>
            implements ReactorSchema
    {

        public CascadeToken name;

        public Core core;

        public CascadeLogger logger;

        public CascadeToken pool;

        public CascadeToken pump;

        public QueueType queueType;

        public Integer queueCapacity;

        public InflowQueue queue;

<span class="fc" id="L850">        public final SortedSet&lt;CascadeToken&gt; subscriptions = Sets.newTreeSet();</span>

        public ConcreteReactor reactor;

        @Override
        public ReactorSchema withCore (final CascadeReactor.Core core)
        {
            // Prevent Nulls
<span class="fc" id="L858">            final Set&lt;CascadeToken&gt; initial = ImmutableSet.copyOf(core.initialSubscriptions());</span>
<span class="fc" id="L859">            subscriptions.addAll(initial);</span>
<span class="fc" id="L860">            this.core = core;</span>
<span class="fc" id="L861">            return this;</span>
        }

        @Override
        public ReactorSchema withCore (final CascadeReactor.CoreBuilder core)
        {
<span class="fc" id="L867">            return withCore(core.build());</span>
        }

        @Override
        public ReactorSchema usingLogger (final CascadeLogger.Factory factory)
        {
<span class="fc" id="L873">            Verify.verifyNotNull(name);</span>
<span class="fc" id="L874">            this.logger = factory.create(name);</span>
<span class="fc" id="L875">            return this;</span>
        }

        @Override
        public ReactorSchema usingPool (final String name)
        {
<span class="fc" id="L881">            this.pool = convertName(name);</span>
<span class="fc" id="L882">            return this;</span>
        }

        @Override
        public ReactorSchema usingPump (final String name)
        {
<span class="fc" id="L888">            this.pump = convertName(name);</span>
<span class="fc" id="L889">            return this;</span>
        }

        @Override
        public ReactorSchema withArrayQueue (final int capacity)
        {
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">            Preconditions.checkArgument(capacity &gt;= 0, &quot;capacity &lt; 0&quot;);</span>
<span class="fc" id="L896">            final QueueType type = QueueType.ARRAY;</span>
<span class="fc" id="L897">            this.queueType = type;</span>
<span class="fc" id="L898">            this.queueCapacity = capacity;</span>
<span class="fc" id="L899">            this.queue = new ArrayInflowQueue(allocator, capacity);</span>
<span class="fc" id="L900">            return this;</span>
        }

        @Override
        public ReactorSchema withLinkedQueue (final int capacity)
        {
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">            Preconditions.checkArgument(capacity &gt;= 0, &quot;capacity &lt; 0&quot;);</span>
<span class="fc" id="L907">            final QueueType type = QueueType.LINKED;</span>
<span class="fc" id="L908">            this.queueType = type;</span>
<span class="fc" id="L909">            this.queueCapacity = capacity;</span>
<span class="fc" id="L910">            this.queue = new LinkedInflowQueue(allocator, capacity);</span>
<span class="fc" id="L911">            return this;</span>
        }

        @Override
        public ReactorSchema subscribeTo (final String event)
        {
<span class="fc" id="L917">            final CascadeToken token = CascadeToken.create(event);</span>
<span class="fc" id="L918">            subscriptions.add(token);</span>
<span class="fc" id="L919">            return this;</span>
        }
    };

<span class="fc" id="L923">    private final class Scope</span>
    {
        public CascadeToken namespace;

        public CascadeLogger.Factory logger;

        public CascadeToken pool;

        public CascadeToken pump;

        public QueueType queueType;

        public Integer queueCapacity;
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>