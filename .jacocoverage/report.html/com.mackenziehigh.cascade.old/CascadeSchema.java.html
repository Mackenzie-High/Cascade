<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CascadeSchema.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade.old</a> &gt; <span class="el_source">CascadeSchema.java</span></div><h1>CascadeSchema.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade.old;

import com.mackenziehigh.cascade.old.CascadeReactor;
import com.mackenziehigh.cascade.old.Cascade;
import com.mackenziehigh.cascade.CascadeLogger;
import com.mackenziehigh.cascade.old.CascadeReactor.Core;
import com.mackenziehigh.cascade.old.internal.ConcreteSchema;
import java.util.concurrent.ThreadFactory;

/**
 * Use an instance of this interface in order to
 * create a Cascade object using a fluent API.
 */
public interface CascadeSchema
{
    /**
     * Describes an allocation-pool.
     */
    public interface PoolSchema
    {
        /**
         * This method causes the pool to become the global default allocation-pool,
         * which will be used by any algorithms that choose to not use a use-site
         * specific allocation-pool.
         *
         * @return this.
         */
        public PoolSchema makeGlobalDefault ();
    }

    /**
     * Describes an allocation-pool that uses on-demand memory allocation.
     *
     * &lt;p&gt;
     * This type of allocation-pool simply allocates a new &lt;code&gt;byte[]&lt;/code&gt;
     * whenever an allocation request is made.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * &lt;b&gt;Advantages:&lt;/b&gt;
     * &lt;ul&gt;
     * &lt;li&gt;
     * Only the amount of memory that is actually needed is allocated per operand;
     * therefore, operands never have wasted padding.
     * &lt;/li&gt;
     * &lt;li&gt;
     * The amount of memory allocated by the pool may grow and shrink as needed,
     * rather than requiring a pre-allocated amount based on programmer expectations.
     * &lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * &lt;b&gt;Disadvantages:&lt;/b&gt;
     * &lt;ul&gt;
     * &lt;li&gt;
     * Allocations put pressure on the garbage-collector. In particular, frequent large
     * allocations may have a negative performance impact, by causing the garbage-collector
     * to have to perform more frequent invasive collections. For example, the (G1) garbage
     * collector automatically promotes large objects to the old-generation.
     * &lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * The default minimum-size is zero and the default maximum-size is &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.
     * &lt;/p&gt;
     */
    public interface DynamicPoolSchema
            extends PoolSchema
    {
        /**
         * Setter.
         *
         * @param bound will be the minimum-size of allocations in the pool.
         * @return this.
         */
        public DynamicPoolSchema withMinimumSize (int bound);

        /**
         * Setter.
         *
         * @param bound will be the maximum-size of allocations in the pool.
         * @return this.
         */
        public DynamicPoolSchema withMaximumSize (int bound);

        /**
         * {@inheritDoc}
         */
        @Override
        public DynamicPoolSchema makeGlobalDefault ();
    }

    /**
     * Describes an allocation-pool that uses preallocated memory.
     *
     * &lt;p&gt;
     * This type of allocation-pool simply allocates a a fixed number
     * of &lt;code&gt;byte[]&lt;/code&gt; buffers at startup. Whenever an allocation
     * request is made, a free buffer is selected and used to fulfill
     * the request. When the buffer is no longer in-use, the buffer
     * is returned to the pool of available buffers.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * &lt;b&gt;Advantages:&lt;/b&gt;
     * &lt;ul&gt;
     * &lt;li&gt;
     * Since the buffers are reused, no pressure is put on the garbage-collector.
     * &lt;/li&gt;
     * &lt;li&gt;
     * The amount of memory allocated by the pool is effectively constant.
     * &lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * &lt;b&gt;Disadvantages:&lt;/b&gt;
     * &lt;ul&gt;
     * &lt;li&gt;
     * The preallocated buffers have a fixed size; therefore,
     * memory will be wasted, if the requested allocation-size
     * is smaller than the size of the buffer.
     * &lt;/li&gt;
     * &lt;li&gt;
     * Since each allocation consumes one whole preallocated buffer,
     * there is a strict limit on the number of simultaneous allocations.
     * Specifically, no more allocations can be made than there are buffers
     * in the pool of preallocated buffers, even if wasted space is present.
     * &lt;/li&gt;
     * &lt;li&gt;
     * Programmers must carefully tune the number of preallocated buffers,
     * based solely upon their expectations of runtime behavior,
     * in order to ensure that an adequate number of buffers will be available
     * without exceeding the available system resources.
     * &lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     */
    public interface FixedPoolSchema
            extends PoolSchema
    {
        /**
         * Setter.
         *
         * @param bound will be the minimum-size of allocations in the pool.
         * @return this.
         */
        public FixedPoolSchema withMinimumSize (int bound);

        /**
         * Setter.
         *
         * @param bound will be the maximum-size of allocations in the pool.
         * @return this.
         */
        public FixedPoolSchema withMaximumSize (int bound);

        /**
         * Setter.
         *
         * @param count will be the number of preallocated memory buffers,
         * which is the maximum number of operands that will be allocated
         * within the allocation-pool at one one time.
         * @return this.
         */
        public FixedPoolSchema withBufferCount (int count);

        /**
         * {@inheritDoc}
         */
        @Override
        public FixedPoolSchema makeGlobalDefault ();
    }

    /**
     * Describes an allocation-pool that delegates to other allocation-pools.
     *
     * &lt;p&gt;
     * A composite-pool consists of a series of member-pools and an optional fallback-pool.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * When an allocation request is made for (X) bytes, the composite-pool will attempt
     * to locate a member-pool whose minimum allocation-size is less-or-equal-to (X)
     * and whose maximum allocation-size is greater-or-equal-to (X). If such a member-pool
     * is found, then the allocation request will be forwarded to that member-pool.
     * If no such member-pool is found and a fallback-pool was specified,
     * then the allocation request will be forwarded to the fallback-pool.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * As usual, each member-pool has its own minimum and maximum allocation-sizes.
     * None of the member-pools can have overlapping allocation-sizes.
     * No such restriction is placed onto the fallback-pool.
     * The member-pools are not required to be contiguous.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * An logarithmic-time, O(log N), search algorithm is used to locate the matching member-pool.
     * Thus, using a composite-pool should not add a meaningful amount of allocation overhead.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * The member-pools and the fallback-pool cannot themselves be composite-pools.
     * This avoids the possibility of recursively-defined composite-pools,
     * which would be prima facia erroneous.
     * &lt;/p&gt;
     */
    public interface CompositePoolSchema
            extends PoolSchema
    {

        /**
         * Setter.
         *
         * &lt;p&gt;
         * If the given name is a simple-name, when treated as a token,
         * then this method will prepend the current namespace onto the name.
         * &lt;/p&gt;
         *
         * @param name is the name of an allocation-pool to use,
         * if none of the other allocation-pools are appropriate.
         * @return this.
         */
        public CompositePoolSchema withFallbackPool (String name);

        /**
         * Setter.
         *
         * &lt;p&gt;
         * This method may be invoked multiple times.
         * &lt;/p&gt;
         *
         * &lt;p&gt;
         * If the given name is a simple-name, when treated as a token,
         * then this method will prepend the current namespace onto the name.
         * &lt;/p&gt;
         *
         * @param name is the name of an allocation-pool that this pool
         * will delegate to in order to perform allocations.
         * @return this.
         */
        public CompositePoolSchema withMemberPool (String name);

        /**
         * {@inheritDoc}
         */
        @Override
        public CompositePoolSchema makeGlobalDefault ();
    }

    /**
     * Describes a pump consisting of a pool of threads.
     *
     * &lt;p&gt;
     * By default, the pool will have one thread,
     * which will be a non-daemon thread.
     * &lt;/p&gt;
     */
    public interface PumpSchema
    {

        /**
         * Setter.
         *
         * @param factory will be used to create the threads in the thread-pool.
         * @return this.
         */
        public PumpSchema usingThreadFactory (ThreadFactory factory);

        /**
         * Setter.
         *
         * @param count will be the number of threads in the thread-pool.
         * @return this.
         */
        public PumpSchema withThreadCount (int count);

    }

    /**
     * Describes a reactor, its core, and its queue.
     *
     * &lt;p&gt;
     * If no queue, logger, pool, or pump settings are explicitly specified,
     * then the reactor will use the default setting from the enclosing scope.
     * &lt;/p&gt;
     */
    public interface ReactorSchema
    {

        /**
         * Setter.
         *
         * @param core will be the core of the reactor.
         * @return this.
         */
        public ReactorSchema withCore (Core core);

        /**
         * Setter.
         *
         * @param core will produce the core of the reactor.
         * @return this.
         */
        public ReactorSchema withCore (CascadeReactor.CoreBuilder core);

        /**
         * Setter.
         *
         * @param factory will be used to create a logger for the reactor.
         * @return this.
         */
        public ReactorSchema usingLogger (CascadeLogger.Factory factory);

        /**
         * Setter.
         *
         * &lt;p&gt;
         * If the given name is a simple-name, when treated as a token,
         * then this method will prepend the current namespace onto the name.
         * &lt;/p&gt;
         *
         * @param name identifies the allocation-pool for the reactor to use.
         * @return this.
         */
        public ReactorSchema usingPool (String name);

        /**
         * Setter.
         *
         * &lt;p&gt;
         * If the given name is a simple-name, when treated as a token,
         * then this method will prepend the current namespace onto the name.
         * &lt;/p&gt;
         *
         * @param name identifies the pump for the reactor to use.
         * @return this.
         */
        public ReactorSchema usingPump (String name);

        /**
         * This method will cause the reactor to use a non-circular
         * array-queue in order to store pending event-messages.
         *
         * @param capacity will be the maximum-size of the queue.
         * @return this.
         */
        public ReactorSchema withArrayQueue (int capacity);

        /**
         * This method will cause the reactor to use a non-circular
         * linked-queue in order to store pending event-messages.
         *
         * @param capacity will be the maximum-size of the queue.
         * @return this.
         */
        public ReactorSchema withLinkedQueue (int capacity);

        /**
         * This method causes the reactor to be subscribed to a named event-channel; therefore,
         * the reactor will receive any event-messages sent to that channel at runtime.
         *
         * &lt;p&gt;
         * This method may be invoked multiple times in order to subscribe to multiple event-channels.
         * &lt;/p&gt;
         *
         * &lt;p&gt;
         * Subsequent invocations of this method, given the same argument, are no-ops.
         * &lt;/p&gt;
         *
         * @param event is the exact name of the event-channel.
         * @return this.
         */
        public ReactorSchema subscribeTo (String event);
    }

    /**
     * Use this method to enter a new scope.
     *
     * &lt;p&gt;
     * The default logger-factory, pool, and pump
     * of the current scope, if any, will be inherited by
     * the new scope.
     * &lt;/p&gt;
     *
     *
     * @param name is the namespace to enter.
     * @return this.
     */
    public CascadeSchema enter (String name);

    /**
     * This method causes reactors subsequently added to this scope
     * to use the given logger-factory, unless another logger-factory
     * is explicitly specified for the reactor.
     *
     * @param factory will be the default logger-factory for reactors in this scope.
     * @return this.
     */
    public CascadeSchema usingLogger (CascadeLogger.Factory factory);

    /**
     * This method causes reactors subsequently added to this scope
     * to use the allocation-pool with the given name, unless another
     * allocation-pool is explicitly specified for the reactor.
     *
     * &lt;p&gt;
     * If the given name is a simple-name, when treated as a token,
     * then this method will prepend the current namespace onto the name.
     * &lt;/p&gt;
     *
     * @param name identifies the default allocation-pool for reactors in this scope.
     * @return this.
     */
    public CascadeSchema usingPool (String name);

    /**
     * This method causes reactors subsequently added to this scope
     * to use the pump with the given name, unless another pump
     * is explicitly specified for the reactor.
     *
     * &lt;p&gt;
     * If the given name is a simple-name, when treated as a token,
     * then this method will prepend the current namespace onto the name.
     * &lt;/p&gt;
     *
     * @param name identifies the default pump for reactors in this scope.
     * @return this.
     */
    public CascadeSchema usingPump (String name);

    /**
     * This method causes reactors subsequently added to this scope
     * to use a linked-queue with the given capacity,
     * unless explicitly specified otherwise.
     *
     * @param capacity will be the default queue-capacity.
     * @return this.
     */
    public CascadeSchema usingLinkedQueues (int capacity);

    /**
     * This method causes reactors subsequently added to this scope
     * to use an array-queue with the given capacity,
     * unless explicitly specified otherwise.
     *
     * @param capacity will be the default queue-capacity.
     * @return this.
     */
    public CascadeSchema usingArrayQueues (int capacity);

    /**
     * Use this method to add a dynamic allocation-pool.
     *
     * &lt;p&gt;
     * If the given name is a simple-name, when treated as a token,
     * then this method will prepend the current namespace onto the name.
     * &lt;/p&gt;
     *
     * @param name will be the name of the new pool.
     * @return this.
     */
    public DynamicPoolSchema addDynamicPool (String name);

    /**
     * Use this method to add a fixed allocation-pool.
     *
     *      * &lt;p&gt;
     * If the given name is a simple-name, when treated as a token,
     * then this method will prepend the current namespace onto the name.
     * &lt;/p&gt;
     *
     * @param name will be the name of the new pool.
     * @return this.
     */
    public FixedPoolSchema addFixedPool (String name);

    /**
     * Use this method to add a composite allocation-pool.
     *
     * &lt;p&gt;
     * If the given name is a simple-name, when treated as a token,
     * then this method will prepend the current namespace onto the name.
     * &lt;/p&gt;
     *
     * @param name will be the name of the new pool.
     * @return this.
     */
    public CompositePoolSchema addCompositePool (String name);

    /**
     * Use this method to add a pump.
     *
     * &lt;p&gt;
     * If the given name is a simple-name, when treated as a token,
     * then this method will prepend the current namespace onto the name.
     * &lt;/p&gt;
     *
     * @param name will be the name of the new pump.
     * @return this.
     */
    public PumpSchema addPump (String name);

    /**
     * Use this method to add a reactor.
     *
     * &lt;p&gt;
     * If the given name is a simple-name, when treated as a token,
     * then this method will prepend the current namespace onto the name.
     * &lt;/p&gt;
     *
     * @param name will be the name of the new reactor.
     * @return this.
     */
    public ReactorSchema addReactor (String name);

    /**
     * Use this method to construct a Cascade object from this schema.
     *
     * @return the new object.
     */
    public Cascade build ();

    /**
     * Factory Method.
     *
     * @param name will be the name of the new Cascade object.
     * @return a new instance of this interface.
     */
    public static CascadeSchema create (final String name)
    {
<span class="nc" id="L535">        return new ConcreteSchema(name);</span>
    }

    /**
     * Factory Method.
     *
     * @param name will be the name of the new Cascade object.
     * @return a new instance of this interface with default settings.
     */
    public static CascadeSchema createSimple (final String name)
    {
        // TODO: Finish
<span class="nc" id="L547">        final CascadeSchema schema = create(name);</span>
<span class="nc" id="L548">        schema.addDynamicPool(&quot;default&quot;).withMinimumSize(0).withMaximumSize(Integer.MAX_VALUE);</span>
<span class="nc" id="L549">        schema.addPump(&quot;pump&quot;).withThreadCount(Runtime.getRuntime().availableProcessors() + 1);</span>
<span class="nc" id="L550">        schema.usingPool(&quot;default&quot;);</span>
<span class="nc" id="L551">        schema.usingPump(&quot;pump&quot;);</span>
<span class="nc" id="L552">        return schema;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>