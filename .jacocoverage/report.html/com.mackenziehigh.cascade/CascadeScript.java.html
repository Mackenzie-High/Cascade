<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CascadeScript.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade</a> &gt; <span class="el_source">CascadeScript.java</span></div><h1>CascadeScript.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Scripts define how actors behave in-response to events.
 */
<span class="fc" id="L16">public final class CascadeScript</span>
{

    /**
     * Lambda function whose signature is the same as the onSetup() event-handler.
     */
    @FunctionalInterface
    public interface SetupFunction
    {
        public void accept (CascadeContext ctx)
                throws Throwable;
    }

    /**
     * Lambda function whose signature is the same as the onMessage() event-handler.
     */
    @FunctionalInterface
    public interface MessageFunction
    {
        public void accept (CascadeContext ctx,
                            CascadeToken event,
                            CascadeStack stack)
                throws Throwable;
    }

    /**
     * Lambda function whose signature is the same as the onUnhandledException() event-handler.
     */
    @FunctionalInterface
    public interface ExceptionFunction
    {
        public void accept (CascadeContext ctx,
                            Throwable cause)
                throws Throwable;
    }

    /**
     * Lambda function whose signature is the same as the onClose() event-handler.
     */
    @FunctionalInterface
    public interface CloseFunction
    {
        public void accept (CascadeContext ctx)
                throws Throwable;
    }

<span class="fc" id="L62">    private final AtomicBoolean started = new AtomicBoolean();</span>

<span class="fc" id="L64">    private final AtomicBoolean stopped = new AtomicBoolean();</span>

<span class="fc" id="L66">    private volatile List&lt;SetupFunction&gt; setupFunctions = ImmutableList.of();</span>

<span class="fc" id="L68">    private final Map&lt;CascadeToken, List&lt;MessageFunction&gt;&gt; messageFunctions = new ConcurrentHashMap&lt;&gt;(8);</span>

<span class="fc" id="L70">    private volatile List&lt;ExceptionFunction&gt; exceptionFunctions = ImmutableList.of();</span>

<span class="fc" id="L72">    private volatile List&lt;CloseFunction&gt; closeFunctions = ImmutableList.of();</span>

<span class="fc" id="L74">    private final Object eventHandlerLock = new Object();</span>

    /**
     * This lock is used to prevent concurrent modifications of the data-structures herein.
     *
     * &lt;p&gt;
     * This lock is separate from the event-handler lock, because long-running event-handlers
     * shall not prevent the data-structures from being modified concurrently.
     * &lt;/p&gt;
     */
<span class="fc" id="L84">    private final Object dataStructureLock = new Object();</span>

    /**
     * This event-handler will be executed when the enclosing actor is setup.
     *
     * @param ctx provides access to the actor itself, etc.
     * @throws Throwable if something horrible happens.
     */
    public void onSetup (final CascadeContext ctx)
            throws Throwable
    {
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (started.compareAndSet(false, true) == false)</span>
        {
<span class="nc" id="L97">            return; // Already Starting or Started.</span>
        }

<span class="nc" id="L100">        synchronized (eventHandlerLock)</span>
        {
            try
            {
<span class="nc" id="L104">                subscribe(ctx);</span>

<span class="nc" id="L106">                final List&lt;SetupFunction&gt; array = setupFunctions;</span>

<span class="nc bnc" id="L108" title="All 2 branches missed.">                for (int i = 0; i &lt; array.size(); i++)</span>
                {
<span class="nc" id="L110">                    array.get(i).accept(ctx);</span>
                }
            }
<span class="nc" id="L113">            catch (Throwable ex)</span>
            {
<span class="nc" id="L115">                onUnhandledException(ctx, ex);</span>
<span class="nc" id="L116">            }</span>
<span class="nc" id="L117">        }</span>
<span class="nc" id="L118">    }</span>

    /**
     * This event-handler will be executed whenever the enclosing actor
     * dequeues an event-message for processing herein.
     *
     * @param ctx provides access to the actor itself, etc.
     * @param event identifies the event that created the message.
     * @param stack contains the content of the message.
     * @throws Throwable if something horrible happens.
     */
    public void onMessage (final CascadeContext ctx,
                           final CascadeToken event,
                           final CascadeStack stack)
            throws Throwable
    {
<span class="nc" id="L134">        synchronized (eventHandlerLock)</span>
        {
            try
            {
<span class="nc" id="L138">                final List&lt;MessageFunction&gt; array = messageFunctions.getOrDefault(event, Collections.EMPTY_LIST);</span>

<span class="nc bnc" id="L140" title="All 2 branches missed.">                for (int i = 0; i &lt; array.size(); i++)</span>
                {
<span class="nc" id="L142">                    array.get(i).accept(ctx, event, stack);</span>
                }
            }
<span class="nc" id="L145">            catch (Throwable ex)</span>
            {
<span class="nc" id="L147">                onUnhandledException(ctx, ex);</span>
<span class="nc" id="L148">            }</span>
<span class="nc" id="L149">        }</span>
<span class="nc" id="L150">    }</span>

    /**
     * This event-handler will be executed whenever the enclosing
     * actor throws and unhandled exception of any kind.
     *
     * &lt;p&gt;
     * This method will be invoked given an unhandled exception
     * that is thrown by any of the other event-handlers,
     * but not those thrown by itself.
     * &lt;/p&gt;
     *
     * @param ctx provides access to the actor itself, etc.
     * @param cause is the unhandled exception that was thrown.
     * @throws Throwable if something horrible happens.
     */
    private void onException (final CascadeContext ctx,
                              final Throwable cause)
            throws Throwable
    {
<span class="nc" id="L170">        synchronized (eventHandlerLock)</span>
        {
<span class="nc" id="L172">            final List&lt;ExceptionFunction&gt; array = exceptionFunctions;</span>

<span class="nc bnc" id="L174" title="All 2 branches missed.">            for (int i = 0; i &lt; array.size(); i++)</span>
            {
<span class="nc" id="L176">                array.get(i).accept(ctx, cause);</span>
            }
<span class="nc" id="L178">        }</span>
<span class="nc" id="L179">    }</span>

    /**
     * This event-handler will be executed when the enclosing actor is closed.
     *
     * @param ctx provides access to the actor itself, etc.
     * @throws Throwable if something horrible happens.
     */
    public void onClose (final CascadeContext ctx)
            throws Throwable
    {
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (stopped.compareAndSet(false, true) == false)</span>
        {
<span class="nc" id="L192">            return; // Already Stopping or Stopped.</span>
        }

<span class="fc" id="L195">        synchronized (eventHandlerLock)</span>
        {
            try
            {
<span class="fc" id="L199">                final List&lt;CloseFunction&gt; array = closeFunctions;</span>

<span class="pc bpc" id="L201" title="1 of 2 branches missed.">                for (int i = 0; i &lt; array.size(); i++)</span>
                {
<span class="nc" id="L203">                    array.get(i).accept(ctx);</span>
                }
            }
<span class="nc" id="L206">            catch (Throwable ex1)</span>
            {
<span class="nc" id="L208">                onUnhandledException(ctx, ex1);</span>
            }
            finally
            {
<span class="nc" id="L212">                try</span>
                {
<span class="pc" id="L214">                    unsubscribe(ctx);</span>
                }
<span class="nc" id="L216">                catch (Throwable ex2)</span>
                {
<span class="nc" id="L218">                    onUnhandledException(ctx, ex2);</span>
<span class="pc" id="L219">                }</span>
<span class="nc" id="L220">            }</span>
<span class="pc" id="L221">        }</span>
<span class="fc" id="L222">    }</span>

    /**
     * Prepend the given function onto the list of actions
     * to perform in order to setup the enclosing actor.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript prependToOnSetup (final SetupFunction functor)
    {
<span class="nc" id="L233">        synchronized (dataStructureLock)</span>
        {
<span class="nc" id="L235">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="nc" id="L236">            final ImmutableList.Builder&lt;SetupFunction&gt; builder = ImmutableList.builder();</span>
<span class="nc" id="L237">            builder.add(functor);</span>
<span class="nc" id="L238">            builder.addAll(setupFunctions);</span>
<span class="nc" id="L239">            setupFunctions = builder.build();</span>
<span class="nc" id="L240">            return this;</span>
<span class="nc" id="L241">        }</span>
    }

    /**
     * Append the given function onto the list of actions
     * to perform in order to setup the enclosing actor.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript appendToOnSetup (final SetupFunction functor)
    {
<span class="nc" id="L253">        synchronized (dataStructureLock)</span>
        {
<span class="nc" id="L255">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="nc" id="L256">            final ImmutableList.Builder&lt;SetupFunction&gt; builder = ImmutableList.builder();</span>
<span class="nc" id="L257">            builder.addAll(setupFunctions);</span>
<span class="nc" id="L258">            builder.add(functor);</span>
<span class="nc" id="L259">            setupFunctions = builder.build();</span>
<span class="nc" id="L260">            return this;</span>
<span class="nc" id="L261">        }</span>
    }

    /**
     * Remove an element from the list of setup actions, if present.
     *
     * @param functor will be removed from the list.
     * @return this.
     */
    public CascadeScript removeOnSetup (final SetupFunction functor)
    {
<span class="nc" id="L272">        synchronized (dataStructureLock)</span>
        {
<span class="nc" id="L274">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="nc" id="L275">            final List&lt;SetupFunction&gt; builder = Lists.newArrayList(setupFunctions);</span>
<span class="nc" id="L276">            setupFunctions.remove(functor);</span>
<span class="nc" id="L277">            setupFunctions = ImmutableList.copyOf(builder);</span>
<span class="nc" id="L278">            return this;</span>
<span class="nc" id="L279">        }</span>
    }

    /**
     * Prepend the given function onto the list of actions to perform
     * in order to handle a message caused by the given event.
     *
     * @param event identifies an event-channel.
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript prependToOnMessage (final CascadeToken event,
                                             final MessageFunction functor)
    {
<span class="nc" id="L293">        synchronized (dataStructureLock)</span>
        {
<span class="nc" id="L295">            final List&lt;MessageFunction&gt; original = messageFunctions.getOrDefault(event, Collections.EMPTY_LIST);</span>
<span class="nc" id="L296">            final List&lt;MessageFunction&gt; builder = Lists.newArrayListWithCapacity(original.size() + 1);</span>
<span class="nc" id="L297">            builder.add(0, functor);</span>
<span class="nc" id="L298">            builder.addAll(original);</span>
<span class="nc" id="L299">            final List&lt;MessageFunction&gt; modified = ImmutableList.copyOf(builder);</span>
<span class="nc" id="L300">            messageFunctions.put(event, modified);</span>
<span class="nc" id="L301">            return this;</span>
<span class="nc" id="L302">        }</span>
    }

    /**
     * Append the given function onto the list of actions to perform
     * in order to handle a message caused by the given event.
     *
     * @param event identifies an event-channel.
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript appendToOnMessage (final CascadeToken event,
                                            final MessageFunction functor)
    {
<span class="nc" id="L316">        synchronized (dataStructureLock)</span>
        {
<span class="nc" id="L318">            final List&lt;MessageFunction&gt; original = messageFunctions.getOrDefault(event, Collections.EMPTY_LIST);</span>
<span class="nc" id="L319">            final List&lt;MessageFunction&gt; builder = Lists.newArrayListWithCapacity(original.size() + 1);</span>
<span class="nc" id="L320">            builder.addAll(original);</span>
<span class="nc" id="L321">            builder.add(0, functor);</span>
<span class="nc" id="L322">            final List&lt;MessageFunction&gt; modified = ImmutableList.copyOf(builder);</span>
<span class="nc" id="L323">            messageFunctions.put(event, modified);</span>
<span class="nc" id="L324">            return this;</span>
<span class="nc" id="L325">        }</span>
    }

    /**
     * Remove an element from the list of message-handler actions, if present.
     *
     * @param event identifies the relevant event-channel.
     * @param functor will be removed from the list.
     * @return this.
     */
    public CascadeScript removeOnMessage (final CascadeToken event,
                                          final MessageFunction functor)
    {
<span class="nc" id="L338">        synchronized (dataStructureLock)</span>
        {
<span class="nc" id="L340">            final List&lt;MessageFunction&gt; original = messageFunctions.getOrDefault(event, Collections.EMPTY_LIST);</span>
<span class="nc" id="L341">            final List&lt;MessageFunction&gt; builder = Lists.newArrayList(original);</span>
<span class="nc" id="L342">            builder.remove(functor);</span>
<span class="nc" id="L343">            final List&lt;MessageFunction&gt; modified = ImmutableList.copyOf(builder);</span>
<span class="nc" id="L344">            messageFunctions.put(event, modified);</span>
<span class="nc" id="L345">            return this;</span>
<span class="nc" id="L346">        }</span>
    }

    /**
     * Prepend the given function onto the list of actions
     * to perform in order to handle unhandled exceptions.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript prependToOnException (final ExceptionFunction functor)
    {
<span class="nc" id="L358">        synchronized (dataStructureLock)</span>
        {
<span class="nc" id="L360">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="nc" id="L361">            final ImmutableList.Builder&lt;ExceptionFunction&gt; builder = ImmutableList.builder();</span>
<span class="nc" id="L362">            builder.add(functor);</span>
<span class="nc" id="L363">            builder.addAll(exceptionFunctions);</span>
<span class="nc" id="L364">            exceptionFunctions = builder.build();</span>
<span class="nc" id="L365">            return this;</span>
<span class="nc" id="L366">        }</span>
    }

    /**
     * Append the given function onto the list of actions
     * to perform in order to handle unhandled exceptions.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript appendToOnException (final ExceptionFunction functor)
    {
<span class="nc" id="L378">        synchronized (dataStructureLock)</span>
        {
<span class="nc" id="L380">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="nc" id="L381">            final ImmutableList.Builder&lt;ExceptionFunction&gt; builder = ImmutableList.builder();</span>
<span class="nc" id="L382">            builder.addAll(exceptionFunctions);</span>
<span class="nc" id="L383">            builder.add(functor);</span>
<span class="nc" id="L384">            exceptionFunctions = builder.build();</span>
<span class="nc" id="L385">            return this;</span>
<span class="nc" id="L386">        }</span>
    }

    /**
     * Remove an element from the list of unhandled-exception handlers, if present.
     *
     * @param functor will be removed from the list.
     * @return this.
     */
    public CascadeScript removeOnException (final ExceptionFunction functor)
    {
<span class="nc" id="L397">        synchronized (dataStructureLock)</span>
        {
<span class="nc" id="L399">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="nc" id="L400">            final List&lt;ExceptionFunction&gt; builder = Lists.newArrayList(exceptionFunctions);</span>
<span class="nc" id="L401">            exceptionFunctions.remove(functor);</span>
<span class="nc" id="L402">            exceptionFunctions = ImmutableList.copyOf(builder);</span>
<span class="nc" id="L403">            return this;</span>
<span class="nc" id="L404">        }</span>
    }

    /**
     * Prepend the given function onto the list of actions
     * to perform in order to close the enclosing actor.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript prependToOnClose (final CloseFunction functor)
    {
<span class="nc" id="L416">        synchronized (dataStructureLock)</span>
        {
<span class="nc" id="L418">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="nc" id="L419">            final ImmutableList.Builder&lt;CloseFunction&gt; builder = ImmutableList.builder();</span>
<span class="nc" id="L420">            builder.add(functor);</span>
<span class="nc" id="L421">            builder.addAll(closeFunctions);</span>
<span class="nc" id="L422">            closeFunctions = builder.build();</span>
<span class="nc" id="L423">            return this;</span>
<span class="nc" id="L424">        }</span>
    }

    /**
     * Append the given function onto the list of actions
     * to perform in order to close the enclosing actor.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript appendToOnClose (final CloseFunction functor)
    {
<span class="nc" id="L436">        synchronized (dataStructureLock)</span>
        {
<span class="nc" id="L438">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="nc" id="L439">            final ImmutableList.Builder&lt;CloseFunction&gt; builder = ImmutableList.builder();</span>
<span class="nc" id="L440">            builder.addAll(closeFunctions);</span>
<span class="nc" id="L441">            builder.add(functor);</span>
<span class="nc" id="L442">            closeFunctions = builder.build();</span>
<span class="nc" id="L443">            return this;</span>
<span class="nc" id="L444">        }</span>
    }

    /**
     * Remove an element from the list of close actions, if present.
     *
     * @param functor will be removed from the list.
     * @return this.
     */
    public CascadeScript removeOnClose (final CloseFunction functor)
    {
<span class="nc" id="L455">        synchronized (dataStructureLock)</span>
        {
<span class="nc" id="L457">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="nc" id="L458">            final List&lt;CloseFunction&gt; builder = Lists.newArrayList(closeFunctions);</span>
<span class="nc" id="L459">            closeFunctions.remove(functor);</span>
<span class="nc" id="L460">            closeFunctions = ImmutableList.copyOf(builder);</span>
<span class="nc" id="L461">            return this;</span>
<span class="nc" id="L462">        }</span>
    }

    /**
     * Getter.
     *
     * @return the sequence of actions required to setup the enclosing actor.
     */
    public List&lt;SetupFunction&gt; setupScript ()
    {
<span class="fc" id="L472">        return ImmutableList.copyOf(setupFunctions);</span>
    }

    /**
     * Getter.
     *
     * @return the sequence of actions required to process an event-message.
     */
    public Map&lt;CascadeToken, List&lt;MessageFunction&gt;&gt; messageScript ()
    {
<span class="fc" id="L482">        final ImmutableMap.Builder&lt;CascadeToken, List&lt;MessageFunction&gt;&gt; map = ImmutableMap.builder();</span>

<span class="pc bpc" id="L484" title="1 of 2 branches missed.">        for (CascadeToken key : messageFunctions.keySet())</span>
        {
<span class="nc" id="L486">            map.put(key, messageFunctions.getOrDefault(key, Collections.EMPTY_LIST));</span>
<span class="nc" id="L487">        }</span>

<span class="fc" id="L489">        return map.build();</span>
    }

    /**
     * Getter.
     *
     * @return the sequence of actions required to handle an unhandled-exception.
     */
    public List&lt;ExceptionFunction&gt; exceptionScript ()
    {
<span class="fc" id="L499">        return ImmutableList.copyOf(exceptionFunctions);</span>
    }

    /**
     * Getter.
     *
     * @return the sequence of actions required to close the enclosing actor.
     */
    public List&lt;CloseFunction&gt; closeScript ()
    {
<span class="fc" id="L509">        return ImmutableList.copyOf(closeFunctions);</span>
    }

    private void onUnhandledException (final CascadeContext ctx,
                                       final Throwable cause)
    {
        try
        {
<span class="nc" id="L517">            reinterruptIfNeeded(cause);</span>
<span class="nc" id="L518">            onException(ctx, cause);</span>
        }
<span class="nc" id="L520">        catch (Throwable ex1)</span>
        {
            try
            {
<span class="nc" id="L524">                reinterruptIfNeeded(cause);</span>
<span class="nc" id="L525">                onException(ctx, ex1);</span>
            }
<span class="nc" id="L527">            catch (Throwable ex2)</span>
            {
                try
                {
<span class="nc" id="L531">                    reinterruptIfNeeded(cause);</span>
<span class="nc" id="L532">                    ex1.printStackTrace(System.err);</span>
                }
<span class="nc" id="L534">                catch (Throwable ex3)</span>
                {
                    // Pass. Oh my, you are in some deep trouble.
<span class="nc" id="L537">                }</span>
<span class="nc" id="L538">            }</span>
<span class="nc" id="L539">        }</span>
<span class="nc" id="L540">    }</span>

    private void reinterruptIfNeeded (final Throwable cause)
    {
<span class="nc bnc" id="L544" title="All 2 branches missed.">        if (cause instanceof InterruptedException)</span>
        {
<span class="nc" id="L546">            Thread.currentThread().interrupt();</span>
        }
<span class="nc" id="L548">    }</span>

    private void subscribe (final CascadeContext ctx)
    {
<span class="nc" id="L552">        messageFunctions.keySet().forEach(evt -&gt; ctx.actor().subscribe(evt));</span>
<span class="nc" id="L553">    }</span>

    private void unsubscribe (final CascadeContext ctx)
    {
<span class="pc" id="L557">        messageFunctions.keySet().forEach(evt -&gt; ctx.actor().unsubscribe(evt));</span>
<span class="fc" id="L558">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>