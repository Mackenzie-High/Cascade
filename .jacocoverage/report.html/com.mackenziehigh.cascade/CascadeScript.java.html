<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CascadeScript.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade</a> &gt; <span class="el_source">CascadeScript.java</span></div><h1>CascadeScript.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Scripts define how actors behave in-response to events.
 */
public final class CascadeScript
{

    /**
     * Lambda function whose signature is the same as the onSetup() event-handler.
     */
    @FunctionalInterface
    public interface OnSetupFunction
    {
        public void accept (CascadeContext ctx)
                throws Throwable;
    }

    /**
     * Lambda function whose signature is the same as the onMessage() event-handler.
     */
    @FunctionalInterface
    public interface OnMessageFunction
    {
        public void accept (CascadeContext ctx,
                            CascadeToken event,
                            CascadeStack stack)
                throws Throwable;
    }

    /**
     * Lambda function whose signature is the same as the onUnhandledException() event-handler.
     */
    @FunctionalInterface
    public interface OnExceptionFunction
    {
        public void accept (CascadeContext ctx,
                            Throwable cause)
                throws Throwable;
    }

    /**
     * Lambda function whose signature is the same as the onClose() event-handler.
     */
    @FunctionalInterface
    public interface OnCloseFunction
    {
        public void accept (CascadeContext ctx)
                throws Throwable;
    }

    private final AtomicLong unhandledExceptionCount;

<span class="fc" id="L65">    private volatile List&lt;OnSetupFunction&gt; setupFunctions = ImmutableList.of();</span>

<span class="fc" id="L67">    private final Map&lt;CascadeToken, List&lt;OnMessageFunction&gt;&gt; messageFunctions = new ConcurrentHashMap&lt;&gt;(8);</span>

<span class="fc" id="L69">    private volatile List&lt;OnExceptionFunction&gt; exceptionFunctions = ImmutableList.of();</span>

<span class="fc" id="L71">    private volatile List&lt;OnCloseFunction&gt; closeFunctions = ImmutableList.of();</span>

<span class="fc" id="L73">    private final Object eventHandlerLock = new Object();</span>

    private final CascadeContext context;

    CascadeScript (final CascadeContext context,
                   final AtomicLong unhandledExeceptionCount)
<span class="fc" id="L79">    {</span>
<span class="fc" id="L80">        this.context = Objects.requireNonNull(context);</span>
<span class="fc" id="L81">        this.unhandledExceptionCount = Objects.requireNonNull(unhandledExeceptionCount);</span>
<span class="fc" id="L82">    }</span>

    /**
     * This lock is used to prevent concurrent modifications of the data-structures herein.
     *
     * &lt;p&gt;
     * This lock is separate from the event-handler lock, because long-running event-handlers
     * shall not prevent the data-structures from being modified concurrently.
     * &lt;/p&gt;
     */
<span class="fc" id="L92">    private final Object dataStructureLock = new Object();</span>

    /**
     * This event-handler will be executed when the enclosing actor is setup.
     *
     * @param ctx provides access to the actor itself, etc.
     * @throws Throwable if something horrible happens.
     */
    public void onSetup (final CascadeContext ctx)
            throws Throwable
    {
<span class="fc" id="L103">        synchronized (eventHandlerLock)</span>
        {
            try
            {
<span class="fc" id="L107">                final List&lt;OnSetupFunction&gt; array = setupFunctions;</span>

<span class="fc bfc" id="L109" title="All 2 branches covered.">                for (int i = 0; i &lt; array.size(); i++)</span>
                {
<span class="fc" id="L111">                    array.get(i).accept(ctx);</span>
                }
            }
<span class="fc" id="L114">            catch (Throwable ex)</span>
            {
<span class="fc" id="L116">                onUnhandledException(ctx, ex);</span>
<span class="fc" id="L117">            }</span>
<span class="pc" id="L118">        }</span>
<span class="fc" id="L119">    }</span>

    /**
     * This event-handler will be executed whenever the enclosing actor
     * dequeues an event-message for processing herein.
     *
     * @param ctx provides access to the actor itself, etc.
     * @param event identifies the event that created the message.
     * @param stack contains the content of the message.
     * @throws Throwable if something horrible happens.
     */
    public void onMessage (final CascadeContext ctx,
                           final CascadeToken event,
                           final CascadeStack stack)
            throws Throwable
    {
<span class="fc" id="L135">        synchronized (eventHandlerLock)</span>
        {
            try
            {
<span class="fc" id="L139">                final List&lt;OnMessageFunction&gt; array = messageFunctions.getOrDefault(event, Collections.EMPTY_LIST);</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">                for (int i = 0; i &lt; array.size(); i++)</span>
                {
<span class="fc" id="L143">                    array.get(i).accept(ctx, event, stack);</span>
                }
            }
<span class="fc" id="L146">            catch (Throwable ex)</span>
            {
<span class="fc" id="L148">                onUnhandledException(ctx, ex);</span>
<span class="fc" id="L149">            }</span>
<span class="pc" id="L150">        }</span>
<span class="fc" id="L151">    }</span>

    /**
     * This event-handler will be executed whenever the enclosing
     * actor throws and unhandled exception of any kind.
     *
     * &lt;p&gt;
     * This method will be invoked given an unhandled exception
     * that is thrown by any of the other event-handlers,
     * but not those thrown by itself.
     * &lt;/p&gt;
     *
     * @param ctx provides access to the actor itself, etc.
     * @param cause is the unhandled exception that was thrown.
     * @throws Throwable if something horrible happens.
     */
    private void onException (final CascadeContext ctx,
                              final Throwable cause)
            throws Throwable
    {
<span class="fc" id="L171">        synchronized (eventHandlerLock)</span>
        {
<span class="fc" id="L173">            final List&lt;OnExceptionFunction&gt; array = exceptionFunctions;</span>

<span class="fc bfc" id="L175" title="All 2 branches covered.">            for (int i = 0; i &lt; array.size(); i++)</span>
            {
<span class="fc" id="L177">                array.get(i).accept(ctx, cause);</span>
            }
<span class="fc" id="L179">        }</span>
<span class="fc" id="L180">    }</span>

    /**
     * This event-handler will be executed when the enclosing actor is closed.
     *
     * @param ctx provides access to the actor itself, etc.
     * @throws Throwable if something horrible happens.
     */
    public void onClose (final CascadeContext ctx)
            throws Throwable
    {
<span class="fc" id="L191">        synchronized (eventHandlerLock)</span>
        {
            try
            {
<span class="fc" id="L195">                final List&lt;OnCloseFunction&gt; array = closeFunctions;</span>

<span class="fc bfc" id="L197" title="All 2 branches covered.">                for (int i = 0; i &lt; array.size(); i++)</span>
                {
<span class="fc" id="L199">                    array.get(i).accept(ctx);</span>
                }
            }
<span class="fc" id="L202">            catch (Throwable ex1)</span>
            {
<span class="fc" id="L204">                onUnhandledException(ctx, ex1);</span>
            }
            finally
            {
<span class="nc" id="L208">                try</span>
                {
<span class="pc" id="L210">                    unsubscribe(ctx);</span>
                }
<span class="nc" id="L212">                catch (Throwable ex2)</span>
                {
<span class="nc" id="L214">                    onUnhandledException(ctx, ex2);</span>
<span class="pc" id="L215">                }</span>
<span class="nc" id="L216">            }</span>
<span class="pc" id="L217">        }</span>
<span class="fc" id="L218">    }</span>

    /**
     * Prepend the given function onto the list of actions
     * to perform in order to setup the enclosing actor.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript prependToOnSetup (final OnSetupFunction functor)
    {
<span class="fc" id="L229">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L231">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L232">            final ImmutableList.Builder&lt;OnSetupFunction&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L233">            builder.add(functor);</span>
<span class="fc" id="L234">            builder.addAll(setupFunctions);</span>
<span class="fc" id="L235">            setupFunctions = builder.build();</span>
<span class="pc" id="L236">        }</span>
<span class="fc" id="L237">        return this;</span>
    }

    /**
     * Append the given function onto the list of actions
     * to perform in order to setup the enclosing actor.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript appendToOnSetup (final OnSetupFunction functor)
    {
<span class="fc" id="L249">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L251">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L252">            final ImmutableList.Builder&lt;OnSetupFunction&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L253">            builder.addAll(setupFunctions);</span>
<span class="fc" id="L254">            builder.add(functor);</span>
<span class="fc" id="L255">            setupFunctions = builder.build();</span>
<span class="pc" id="L256">        }</span>
<span class="fc" id="L257">        return this;</span>
    }

    /**
     * Remove an element from the list of setup actions, if present.
     *
     * @param functor will be removed from the list.
     * @return this.
     */
    public CascadeScript removeOnSetup (final OnSetupFunction functor)
    {
<span class="fc" id="L268">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L270">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L271">            final List&lt;OnSetupFunction&gt; builder = Lists.newArrayList(setupFunctions);</span>
<span class="fc" id="L272">            builder.remove(functor);</span>
<span class="fc" id="L273">            setupFunctions = ImmutableList.copyOf(builder);</span>
<span class="pc" id="L274">        }</span>
<span class="fc" id="L275">        return this;</span>
    }

    /**
     * Prepend the given function onto the list of actions to perform
     * in order to handle a message caused by the given event.
     *
     * @param event identifies an event-channel.
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript prependToOnMessage (final CascadeToken event,
                                             final OnMessageFunction functor)
    {
<span class="fc" id="L289">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L291">            final List&lt;OnMessageFunction&gt; original = messageFunctions.getOrDefault(event, Collections.EMPTY_LIST);</span>
<span class="fc" id="L292">            final List&lt;OnMessageFunction&gt; builder = Lists.newArrayListWithCapacity(original.size() + 1);</span>
<span class="fc" id="L293">            builder.add(0, functor);</span>
<span class="fc" id="L294">            builder.addAll(original);</span>
<span class="fc" id="L295">            final List&lt;OnMessageFunction&gt; modified = ImmutableList.copyOf(builder);</span>
<span class="fc" id="L296">            messageFunctions.put(event, modified);</span>
<span class="fc" id="L297">            context.actor().subscribe(event);</span>
<span class="pc" id="L298">        }</span>
<span class="fc" id="L299">        return this;</span>
    }

    /**
     * Append the given function onto the list of actions to perform
     * in order to handle a message caused by the given event.
     *
     * @param event identifies an event-channel.
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript appendToOnMessage (final CascadeToken event,
                                            final OnMessageFunction functor)
    {
<span class="fc" id="L313">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L315">            final List&lt;OnMessageFunction&gt; original = messageFunctions.getOrDefault(event, Collections.EMPTY_LIST);</span>
<span class="fc" id="L316">            final List&lt;OnMessageFunction&gt; builder = Lists.newArrayListWithCapacity(original.size() + 1);</span>
<span class="fc" id="L317">            builder.addAll(original);</span>
<span class="fc" id="L318">            builder.add(functor);</span>
<span class="fc" id="L319">            final List&lt;OnMessageFunction&gt; modified = ImmutableList.copyOf(builder);</span>
<span class="fc" id="L320">            messageFunctions.put(event, modified);</span>
<span class="fc" id="L321">            context.actor().subscribe(event);</span>
<span class="pc" id="L322">        }</span>
<span class="fc" id="L323">        return this;</span>
    }

    /**
     * Remove an element from the list of message-handler actions, if present.
     *
     * @param event identifies the relevant event-channel.
     * @param functor will be removed from the list.
     * @return this.
     */
    public CascadeScript removeOnMessage (final CascadeToken event,
                                          final OnMessageFunction functor)
    {
<span class="fc" id="L336">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L338">            final List&lt;OnMessageFunction&gt; original = messageFunctions.getOrDefault(event, Collections.EMPTY_LIST);</span>
<span class="fc" id="L339">            final List&lt;OnMessageFunction&gt; builder = Lists.newArrayList(original);</span>
<span class="fc" id="L340">            builder.remove(functor);</span>
<span class="fc" id="L341">            final List&lt;OnMessageFunction&gt; modified = ImmutableList.copyOf(builder);</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">            if (modified.isEmpty())</span>
            {
<span class="fc" id="L344">                context.actor().unsubscribe(event);</span>
<span class="fc" id="L345">                messageFunctions.remove(event);</span>
            }
            else
            {
<span class="fc" id="L349">                messageFunctions.put(event, modified);</span>
            }
<span class="pc" id="L351">        }</span>
<span class="fc" id="L352">        return this;</span>
    }

    /**
     * Prepend the given function onto the list of actions
     * to perform in order to handle unhandled exceptions.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript prependToOnException (final OnExceptionFunction functor)
    {
<span class="fc" id="L364">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L366">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L367">            final ImmutableList.Builder&lt;OnExceptionFunction&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L368">            builder.add(functor);</span>
<span class="fc" id="L369">            builder.addAll(exceptionFunctions);</span>
<span class="fc" id="L370">            exceptionFunctions = builder.build();</span>
<span class="pc" id="L371">        }</span>
<span class="fc" id="L372">        return this;</span>
    }

    /**
     * Append the given function onto the list of actions
     * to perform in order to handle unhandled exceptions.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript appendToOnException (final OnExceptionFunction functor)
    {
<span class="fc" id="L384">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L386">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L387">            final ImmutableList.Builder&lt;OnExceptionFunction&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L388">            builder.addAll(exceptionFunctions);</span>
<span class="fc" id="L389">            builder.add(functor);</span>
<span class="fc" id="L390">            exceptionFunctions = builder.build();</span>
<span class="pc" id="L391">        }</span>
<span class="fc" id="L392">        return this;</span>
    }

    /**
     * Remove an element from the list of unhandled-exception handlers, if present.
     *
     * @param functor will be removed from the list.
     * @return this.
     */
    public CascadeScript removeOnException (final OnExceptionFunction functor)
    {
<span class="fc" id="L403">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L405">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L406">            final List&lt;OnExceptionFunction&gt; builder = Lists.newArrayList(exceptionFunctions);</span>
<span class="fc" id="L407">            builder.remove(functor);</span>
<span class="fc" id="L408">            exceptionFunctions = ImmutableList.copyOf(builder);</span>
<span class="pc" id="L409">        }</span>
<span class="fc" id="L410">        return this;</span>
    }

    /**
     * Prepend the given function onto the list of actions
     * to perform in order to close the enclosing actor.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript prependToOnClose (final OnCloseFunction functor)
    {
<span class="fc" id="L422">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L424">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L425">            final ImmutableList.Builder&lt;OnCloseFunction&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L426">            builder.add(functor);</span>
<span class="fc" id="L427">            builder.addAll(closeFunctions);</span>
<span class="fc" id="L428">            closeFunctions = builder.build();</span>
<span class="pc" id="L429">        }</span>
<span class="fc" id="L430">        return this;</span>
    }

    /**
     * Append the given function onto the list of actions
     * to perform in order to close the enclosing actor.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript appendToOnClose (final OnCloseFunction functor)
    {
<span class="fc" id="L442">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L444">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L445">            final ImmutableList.Builder&lt;OnCloseFunction&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L446">            builder.addAll(closeFunctions);</span>
<span class="fc" id="L447">            builder.add(functor);</span>
<span class="fc" id="L448">            closeFunctions = builder.build();</span>
<span class="pc" id="L449">        }</span>
<span class="fc" id="L450">        return this;</span>
    }

    /**
     * Remove an element from the list of close actions, if present.
     *
     * @param functor will be removed from the list.
     * @return this.
     */
    public CascadeScript removeOnClose (final OnCloseFunction functor)
    {
<span class="fc" id="L461">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L463">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L464">            final List&lt;OnCloseFunction&gt; builder = Lists.newArrayList(closeFunctions);</span>
<span class="fc" id="L465">            builder.remove(functor);</span>
<span class="fc" id="L466">            closeFunctions = ImmutableList.copyOf(builder);</span>
<span class="pc" id="L467">        }</span>
<span class="fc" id="L468">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return the sequence of actions required to setup the enclosing actor.
     */
    public List&lt;OnSetupFunction&gt; setupScript ()
    {
<span class="fc" id="L478">        return ImmutableList.copyOf(setupFunctions);</span>
    }

    /**
     * Getter.
     *
     * @return the sequence of actions required to process an event-message.
     */
    public Map&lt;CascadeToken, List&lt;OnMessageFunction&gt;&gt; messageScript ()
    {
<span class="fc" id="L488">        final ImmutableMap.Builder&lt;CascadeToken, List&lt;OnMessageFunction&gt;&gt; map = ImmutableMap.builder();</span>

<span class="fc bfc" id="L490" title="All 2 branches covered.">        for (CascadeToken key : messageFunctions.keySet())</span>
        {
<span class="fc" id="L492">            map.put(key, messageFunctions.getOrDefault(key, Collections.EMPTY_LIST));</span>
<span class="fc" id="L493">        }</span>

<span class="fc" id="L495">        return map.build();</span>
    }

    /**
     * Getter.
     *
     * @return the sequence of actions required to handle an unhandled-exception.
     */
    public List&lt;OnExceptionFunction&gt; exceptionScript ()
    {
<span class="fc" id="L505">        return ImmutableList.copyOf(exceptionFunctions);</span>
    }

    /**
     * Getter.
     *
     * @return the sequence of actions required to close the enclosing actor.
     */
    public List&lt;OnCloseFunction&gt; closeScript ()
    {
<span class="fc" id="L515">        return ImmutableList.copyOf(closeFunctions);</span>
    }

    private void onUnhandledException (final CascadeContext ctx,
                                       final Throwable cause)
    {
        try
        {
<span class="fc" id="L523">            unhandledExceptionCount.incrementAndGet();</span>
<span class="fc" id="L524">            reinterruptIfNeeded(cause);</span>
<span class="fc" id="L525">            onException(ctx, cause);</span>
        }
<span class="fc" id="L527">        catch (Throwable ex1)</span>
        {
            try
            {
<span class="fc" id="L531">                unhandledExceptionCount.incrementAndGet();</span>
<span class="fc" id="L532">                reinterruptIfNeeded(cause);</span>
<span class="nc" id="L533">                onException(ctx, ex1);</span>
            }
<span class="fc" id="L535">            catch (Throwable ex2)</span>
            {
                try
                {
<span class="fc" id="L539">                    unhandledExceptionCount.incrementAndGet();</span>
<span class="fc" id="L540">                    reinterruptIfNeeded(cause);</span>
                }
<span class="nc" id="L542">                catch (Throwable ex3)</span>
                {
                    // Pass. Oh my, you are in some deep trouble.
<span class="fc" id="L545">                }</span>
<span class="nc" id="L546">            }</span>
<span class="fc" id="L547">        }</span>
<span class="fc" id="L548">    }</span>

    private void reinterruptIfNeeded (final Throwable cause)
    {
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">        if (cause instanceof InterruptedException)</span>
        {
<span class="fc" id="L554">            Thread.currentThread().interrupt();</span>
        }
<span class="fc" id="L556">    }</span>

    private void unsubscribe (final CascadeContext ctx)
    {
<span class="fc" id="L560">        messageFunctions.keySet().forEach(evt -&gt; ctx.actor().unsubscribe(evt));</span>
<span class="fc" id="L561">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>