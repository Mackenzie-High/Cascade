<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CascadeScript.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade</a> &gt; <span class="el_source">CascadeScript.java</span></div><h1>CascadeScript.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Scripts define how actors behave in-response to events.
 */
public final class CascadeScript
{

    /**
     * Lambda function whose signature is the same as the onSetup() event-handler.
     */
    @FunctionalInterface
    public interface OnSetupFunction
    {
        public void accept (CascadeContext ctx)
                throws Throwable;
    }

    /**
     * Lambda function whose signature is the same as the onMessage() event-handler.
     */
    @FunctionalInterface
    public interface OnMessageFunction
    {
        public void accept (CascadeContext ctx,
                            CascadeToken event,
                            CascadeStack stack)
                throws Throwable;
    }

    /**
     * Lambda function whose signature is the same as the onUnhandledException() event-handler.
     */
    @FunctionalInterface
    public interface OnExceptionFunction
    {
        public void accept (CascadeContext ctx,
                            Throwable cause)
                throws Throwable;
    }

    /**
     * Lambda function whose signature is the same as the onClose() event-handler.
     */
    @FunctionalInterface
    public interface OnCloseFunction
    {
        public void accept (CascadeContext ctx)
                throws Throwable;
    }

    private final AtomicLong unhandledExceptionCount;

<span class="fc" id="L65">    private volatile List&lt;OnSetupFunction&gt; setupFunctions = ImmutableList.of();</span>

<span class="fc" id="L67">    private final Map&lt;CascadeToken, List&lt;OnMessageFunction&gt;&gt; messageFunctions = new ConcurrentHashMap&lt;&gt;(8);</span>

<span class="fc" id="L69">    private volatile List&lt;OnExceptionFunction&gt; exceptionFunctions = ImmutableList.of();</span>

<span class="fc" id="L71">    private volatile List&lt;OnCloseFunction&gt; closeFunctions = ImmutableList.of();</span>

<span class="fc" id="L73">    private final Object eventHandlerLock = new Object();</span>

    private final CascadeContext context;

    CascadeScript (final CascadeContext context,
                   final AtomicLong unhandledExeceptionCount)
<span class="fc" id="L79">    {</span>
<span class="fc" id="L80">        this.context = Objects.requireNonNull(context);</span>
<span class="fc" id="L81">        this.unhandledExceptionCount = Objects.requireNonNull(unhandledExeceptionCount);</span>
<span class="fc" id="L82">    }</span>

    /**
     * This lock is used to prevent concurrent modifications of the data-structures herein.
     *
     * &lt;p&gt;
     * This lock is separate from the event-handler lock, because long-running event-handlers
     * shall not prevent the data-structures from being modified concurrently.
     * &lt;/p&gt;
     */
<span class="fc" id="L92">    private final Object dataStructureLock = new Object();</span>

    /**
     * This event-handler will be executed when the enclosing actor is setup.
     *
     * @param ctx provides access to the actor itself, etc.
     * @throws Throwable if something horrible happens.
     */
    public void onSetup (final CascadeContext ctx)
            throws Throwable
    {
<span class="fc" id="L103">        synchronized (eventHandlerLock)</span>
        {
            try
            {
<span class="fc" id="L107">                subscribe(ctx);</span>

<span class="fc" id="L109">                final List&lt;OnSetupFunction&gt; array = setupFunctions;</span>

<span class="fc bfc" id="L111" title="All 2 branches covered.">                for (int i = 0; i &lt; array.size(); i++)</span>
                {
<span class="fc" id="L113">                    array.get(i).accept(ctx);</span>
                }
            }
<span class="fc" id="L116">            catch (Throwable ex)</span>
            {
<span class="fc" id="L118">                onUnhandledException(ctx, ex);</span>
<span class="fc" id="L119">            }</span>
<span class="pc" id="L120">        }</span>
<span class="fc" id="L121">    }</span>

    /**
     * This event-handler will be executed whenever the enclosing actor
     * dequeues an event-message for processing herein.
     *
     * @param ctx provides access to the actor itself, etc.
     * @param event identifies the event that created the message.
     * @param stack contains the content of the message.
     * @throws Throwable if something horrible happens.
     */
    public void onMessage (final CascadeContext ctx,
                           final CascadeToken event,
                           final CascadeStack stack)
            throws Throwable
    {
<span class="fc" id="L137">        synchronized (eventHandlerLock)</span>
        {
            try
            {
<span class="fc" id="L141">                final List&lt;OnMessageFunction&gt; array = messageFunctions.getOrDefault(event, Collections.EMPTY_LIST);</span>

<span class="fc bfc" id="L143" title="All 2 branches covered.">                for (int i = 0; i &lt; array.size(); i++)</span>
                {
<span class="fc" id="L145">                    array.get(i).accept(ctx, event, stack);</span>
                }
            }
<span class="fc" id="L148">            catch (Throwable ex)</span>
            {
<span class="fc" id="L150">                onUnhandledException(ctx, ex);</span>
<span class="fc" id="L151">            }</span>
<span class="pc" id="L152">        }</span>
<span class="fc" id="L153">    }</span>

    /**
     * This event-handler will be executed whenever the enclosing
     * actor throws and unhandled exception of any kind.
     *
     * &lt;p&gt;
     * This method will be invoked given an unhandled exception
     * that is thrown by any of the other event-handlers,
     * but not those thrown by itself.
     * &lt;/p&gt;
     *
     * @param ctx provides access to the actor itself, etc.
     * @param cause is the unhandled exception that was thrown.
     * @throws Throwable if something horrible happens.
     */
    private void onException (final CascadeContext ctx,
                              final Throwable cause)
            throws Throwable
    {
<span class="fc" id="L173">        synchronized (eventHandlerLock)</span>
        {
<span class="fc" id="L175">            final List&lt;OnExceptionFunction&gt; array = exceptionFunctions;</span>

<span class="fc bfc" id="L177" title="All 2 branches covered.">            for (int i = 0; i &lt; array.size(); i++)</span>
            {
<span class="fc" id="L179">                array.get(i).accept(ctx, cause);</span>
            }
<span class="fc" id="L181">        }</span>
<span class="fc" id="L182">    }</span>

    /**
     * This event-handler will be executed when the enclosing actor is closed.
     *
     * @param ctx provides access to the actor itself, etc.
     * @throws Throwable if something horrible happens.
     */
    public void onClose (final CascadeContext ctx)
            throws Throwable
    {
<span class="fc" id="L193">        synchronized (eventHandlerLock)</span>
        {
            try
            {
<span class="fc" id="L197">                final List&lt;OnCloseFunction&gt; array = closeFunctions;</span>

<span class="fc bfc" id="L199" title="All 2 branches covered.">                for (int i = 0; i &lt; array.size(); i++)</span>
                {
<span class="fc" id="L201">                    array.get(i).accept(ctx);</span>
                }
            }
<span class="fc" id="L204">            catch (Throwable ex1)</span>
            {
<span class="fc" id="L206">                onUnhandledException(ctx, ex1);</span>
            }
            finally
            {
<span class="nc" id="L210">                try</span>
                {
<span class="pc" id="L212">                    unsubscribe(ctx);</span>
                }
<span class="nc" id="L214">                catch (Throwable ex2)</span>
                {
<span class="nc" id="L216">                    onUnhandledException(ctx, ex2);</span>
<span class="pc" id="L217">                }</span>
<span class="nc" id="L218">            }</span>
<span class="pc" id="L219">        }</span>
<span class="fc" id="L220">    }</span>

    /**
     * Prepend the given function onto the list of actions
     * to perform in order to setup the enclosing actor.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript prependToOnSetup (final OnSetupFunction functor)
    {
<span class="fc" id="L231">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L233">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L234">            final ImmutableList.Builder&lt;OnSetupFunction&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L235">            builder.add(functor);</span>
<span class="fc" id="L236">            builder.addAll(setupFunctions);</span>
<span class="fc" id="L237">            setupFunctions = builder.build();</span>
<span class="fc" id="L238">            return this;</span>
<span class="nc" id="L239">        }</span>
    }

    /**
     * Append the given function onto the list of actions
     * to perform in order to setup the enclosing actor.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript appendToOnSetup (final OnSetupFunction functor)
    {
<span class="fc" id="L251">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L253">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L254">            final ImmutableList.Builder&lt;OnSetupFunction&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L255">            builder.addAll(setupFunctions);</span>
<span class="fc" id="L256">            builder.add(functor);</span>
<span class="fc" id="L257">            setupFunctions = builder.build();</span>
<span class="fc" id="L258">            return this;</span>
<span class="nc" id="L259">        }</span>
    }

    /**
     * Remove an element from the list of setup actions, if present.
     *
     * @param functor will be removed from the list.
     * @return this.
     */
    public CascadeScript removeOnSetup (final OnSetupFunction functor)
    {
<span class="fc" id="L270">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L272">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L273">            final List&lt;OnSetupFunction&gt; builder = Lists.newArrayList(setupFunctions);</span>
<span class="fc" id="L274">            builder.remove(functor);</span>
<span class="fc" id="L275">            setupFunctions = ImmutableList.copyOf(builder);</span>
<span class="fc" id="L276">            return this;</span>
<span class="nc" id="L277">        }</span>
    }

    /**
     * Prepend the given function onto the list of actions to perform
     * in order to handle a message caused by the given event.
     *
     * @param event identifies an event-channel.
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript prependToOnMessage (final CascadeToken event,
                                             final OnMessageFunction functor)
    {
<span class="fc" id="L291">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L293">            final List&lt;OnMessageFunction&gt; original = messageFunctions.getOrDefault(event, Collections.EMPTY_LIST);</span>
<span class="fc" id="L294">            final List&lt;OnMessageFunction&gt; builder = Lists.newArrayListWithCapacity(original.size() + 1);</span>
<span class="fc" id="L295">            builder.add(0, functor);</span>
<span class="fc" id="L296">            builder.addAll(original);</span>
<span class="fc" id="L297">            final List&lt;OnMessageFunction&gt; modified = ImmutableList.copyOf(builder);</span>
<span class="fc" id="L298">            messageFunctions.put(event, modified);</span>
<span class="fc" id="L299">            context.actor().subscribe(event);</span>
<span class="fc" id="L300">            return this;</span>
<span class="nc" id="L301">        }</span>
    }

    /**
     * Append the given function onto the list of actions to perform
     * in order to handle a message caused by the given event.
     *
     * @param event identifies an event-channel.
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript appendToOnMessage (final CascadeToken event,
                                            final OnMessageFunction functor)
    {
<span class="fc" id="L315">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L317">            final List&lt;OnMessageFunction&gt; original = messageFunctions.getOrDefault(event, Collections.EMPTY_LIST);</span>
<span class="fc" id="L318">            final List&lt;OnMessageFunction&gt; builder = Lists.newArrayListWithCapacity(original.size() + 1);</span>
<span class="fc" id="L319">            builder.addAll(original);</span>
<span class="fc" id="L320">            builder.add(functor);</span>
<span class="fc" id="L321">            final List&lt;OnMessageFunction&gt; modified = ImmutableList.copyOf(builder);</span>
<span class="fc" id="L322">            messageFunctions.put(event, modified);</span>
<span class="fc" id="L323">            context.actor().subscribe(event);</span>
<span class="fc" id="L324">            return this;</span>
<span class="nc" id="L325">        }</span>
    }

    /**
     * Remove an element from the list of message-handler actions, if present.
     *
     * @param event identifies the relevant event-channel.
     * @param functor will be removed from the list.
     * @return this.
     */
    public CascadeScript removeOnMessage (final CascadeToken event,
                                          final OnMessageFunction functor)
    {
<span class="fc" id="L338">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L340">            final List&lt;OnMessageFunction&gt; original = messageFunctions.getOrDefault(event, Collections.EMPTY_LIST);</span>
<span class="fc" id="L341">            final List&lt;OnMessageFunction&gt; builder = Lists.newArrayList(original);</span>
<span class="fc" id="L342">            builder.remove(functor);</span>
<span class="fc" id="L343">            final List&lt;OnMessageFunction&gt; modified = ImmutableList.copyOf(builder);</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">            if (modified.isEmpty())</span>
            {
<span class="fc" id="L346">                context.actor().unsubscribe(event);</span>
<span class="fc" id="L347">                messageFunctions.remove(event);</span>
            }
            else
            {
<span class="fc" id="L351">                messageFunctions.put(event, modified);</span>
            }
<span class="fc" id="L353">            return this;</span>
<span class="nc" id="L354">        }</span>
    }

    /**
     * Prepend the given function onto the list of actions
     * to perform in order to handle unhandled exceptions.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript prependToOnException (final OnExceptionFunction functor)
    {
<span class="fc" id="L366">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L368">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L369">            final ImmutableList.Builder&lt;OnExceptionFunction&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L370">            builder.add(functor);</span>
<span class="fc" id="L371">            builder.addAll(exceptionFunctions);</span>
<span class="fc" id="L372">            exceptionFunctions = builder.build();</span>
<span class="fc" id="L373">            return this;</span>
<span class="nc" id="L374">        }</span>
    }

    /**
     * Append the given function onto the list of actions
     * to perform in order to handle unhandled exceptions.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript appendToOnException (final OnExceptionFunction functor)
    {
<span class="fc" id="L386">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L388">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L389">            final ImmutableList.Builder&lt;OnExceptionFunction&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L390">            builder.addAll(exceptionFunctions);</span>
<span class="fc" id="L391">            builder.add(functor);</span>
<span class="fc" id="L392">            exceptionFunctions = builder.build();</span>
<span class="fc" id="L393">            return this;</span>
<span class="nc" id="L394">        }</span>
    }

    /**
     * Remove an element from the list of unhandled-exception handlers, if present.
     *
     * @param functor will be removed from the list.
     * @return this.
     */
    public CascadeScript removeOnException (final OnExceptionFunction functor)
    {
<span class="fc" id="L405">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L407">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L408">            final List&lt;OnExceptionFunction&gt; builder = Lists.newArrayList(exceptionFunctions);</span>
<span class="fc" id="L409">            builder.remove(functor);</span>
<span class="fc" id="L410">            exceptionFunctions = ImmutableList.copyOf(builder);</span>
<span class="fc" id="L411">            return this;</span>
<span class="nc" id="L412">        }</span>
    }

    /**
     * Prepend the given function onto the list of actions
     * to perform in order to close the enclosing actor.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript prependToOnClose (final OnCloseFunction functor)
    {
<span class="fc" id="L424">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L426">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L427">            final ImmutableList.Builder&lt;OnCloseFunction&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L428">            builder.add(functor);</span>
<span class="fc" id="L429">            builder.addAll(closeFunctions);</span>
<span class="fc" id="L430">            closeFunctions = builder.build();</span>
<span class="fc" id="L431">            return this;</span>
<span class="nc" id="L432">        }</span>
    }

    /**
     * Append the given function onto the list of actions
     * to perform in order to close the enclosing actor.
     *
     * @param functor is an action.
     * @return this.
     */
    public CascadeScript appendToOnClose (final OnCloseFunction functor)
    {
<span class="fc" id="L444">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L446">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L447">            final ImmutableList.Builder&lt;OnCloseFunction&gt; builder = ImmutableList.builder();</span>
<span class="fc" id="L448">            builder.addAll(closeFunctions);</span>
<span class="fc" id="L449">            builder.add(functor);</span>
<span class="fc" id="L450">            closeFunctions = builder.build();</span>
<span class="fc" id="L451">            return this;</span>
<span class="nc" id="L452">        }</span>
    }

    /**
     * Remove an element from the list of close actions, if present.
     *
     * @param functor will be removed from the list.
     * @return this.
     */
    public CascadeScript removeOnClose (final OnCloseFunction functor)
    {
<span class="fc" id="L463">        synchronized (dataStructureLock)</span>
        {
<span class="fc" id="L465">            Preconditions.checkNotNull(functor, &quot;functor&quot;);</span>
<span class="fc" id="L466">            final List&lt;OnCloseFunction&gt; builder = Lists.newArrayList(closeFunctions);</span>
<span class="fc" id="L467">            builder.remove(functor);</span>
<span class="fc" id="L468">            closeFunctions = ImmutableList.copyOf(builder);</span>
<span class="fc" id="L469">            return this;</span>
<span class="nc" id="L470">        }</span>
    }

    /**
     * Getter.
     *
     * @return the sequence of actions required to setup the enclosing actor.
     */
    public List&lt;OnSetupFunction&gt; setupScript ()
    {
<span class="fc" id="L480">        return ImmutableList.copyOf(setupFunctions);</span>
    }

    /**
     * Getter.
     *
     * @return the sequence of actions required to process an event-message.
     */
    public Map&lt;CascadeToken, List&lt;OnMessageFunction&gt;&gt; messageScript ()
    {
<span class="fc" id="L490">        final ImmutableMap.Builder&lt;CascadeToken, List&lt;OnMessageFunction&gt;&gt; map = ImmutableMap.builder();</span>

<span class="fc bfc" id="L492" title="All 2 branches covered.">        for (CascadeToken key : messageFunctions.keySet())</span>
        {
<span class="fc" id="L494">            map.put(key, messageFunctions.getOrDefault(key, Collections.EMPTY_LIST));</span>
<span class="fc" id="L495">        }</span>

<span class="fc" id="L497">        return map.build();</span>
    }

    /**
     * Getter.
     *
     * @return the sequence of actions required to handle an unhandled-exception.
     */
    public List&lt;OnExceptionFunction&gt; exceptionScript ()
    {
<span class="fc" id="L507">        return ImmutableList.copyOf(exceptionFunctions);</span>
    }

    /**
     * Getter.
     *
     * @return the sequence of actions required to close the enclosing actor.
     */
    public List&lt;OnCloseFunction&gt; closeScript ()
    {
<span class="fc" id="L517">        return ImmutableList.copyOf(closeFunctions);</span>
    }

    private void onUnhandledException (final CascadeContext ctx,
                                       final Throwable cause)
    {
        try
        {
<span class="fc" id="L525">            unhandledExceptionCount.incrementAndGet();</span>
<span class="fc" id="L526">            reinterruptIfNeeded(cause);</span>
<span class="fc" id="L527">            onException(ctx, cause);</span>
        }
<span class="fc" id="L529">        catch (Throwable ex1)</span>
        {
            try
            {
<span class="fc" id="L533">                unhandledExceptionCount.incrementAndGet();</span>
<span class="fc" id="L534">                reinterruptIfNeeded(cause);</span>
<span class="nc" id="L535">                onException(ctx, ex1);</span>
            }
<span class="fc" id="L537">            catch (Throwable ex2)</span>
            {
                try
                {
<span class="fc" id="L541">                    unhandledExceptionCount.incrementAndGet();</span>
<span class="fc" id="L542">                    reinterruptIfNeeded(cause);</span>
                }
<span class="nc" id="L544">                catch (Throwable ex3)</span>
                {
                    // Pass. Oh my, you are in some deep trouble.
<span class="fc" id="L547">                }</span>
<span class="nc" id="L548">            }</span>
<span class="fc" id="L549">        }</span>
<span class="fc" id="L550">    }</span>

    private void reinterruptIfNeeded (final Throwable cause)
    {
<span class="pc bpc" id="L554" title="1 of 2 branches missed.">        if (cause instanceof InterruptedException)</span>
        {
<span class="fc" id="L556">            Thread.currentThread().interrupt();</span>
        }
<span class="fc" id="L558">    }</span>

    private void subscribe (final CascadeContext ctx)
    {
<span class="fc" id="L562">        messageFunctions.keySet().forEach(evt -&gt; ctx.actor().subscribe(evt));</span>
<span class="fc" id="L563">    }</span>

    private void unsubscribe (final CascadeContext ctx)
    {
<span class="fc" id="L567">        messageFunctions.keySet().forEach(evt -&gt; ctx.actor().unsubscribe(evt));</span>
<span class="fc" id="L568">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>