<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Cascade.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade</a> &gt; <span class="el_source">Cascade.java</span></div><h1>Cascade.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade;

import com.google.common.base.Verify;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.mackenziehigh.cascade.internal.Dispatcher;
import com.mackenziehigh.cascade.internal.PooledExecutor;
import com.mackenziehigh.cascade.internal.ServiceExecutor;
import java.time.Duration;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

/**
 * An instance of this interface contains a concurrent set of stages,
 * where each stage contains zero-or-more actors, which send and receive
 * event-messages for processing according to their scripts.
 */
public final class Cascade
{
    private static final int ACTIVE = 0;

    private static final int CLOSING = 1;

    private static final int CLOSED = 2;

<span class="fc" id="L38">    private final UUID uuid = UUID.randomUUID();</span>

<span class="fc" id="L40">    private final AtomicReference&lt;String&gt; name = new AtomicReference&lt;&gt;(uuid.toString());</span>

    private final Dispatcher dispatcher;

<span class="fc" id="L44">    private final Set&lt;CascadeStage&gt; stages = Sets.newConcurrentHashSet();</span>

<span class="fc" id="L46">    private final AtomicBoolean close = new AtomicBoolean();</span>

<span class="fc" id="L48">    private final AtomicInteger state = new AtomicInteger();</span>

<span class="fc" id="L50">    private final CountDownLatch awaitCloseLatch = new CountDownLatch(1);</span>

<span class="fc" id="L52">    private final Object lock = new Object();</span>

    /**
     * Sole Constructor.
     *
     * @param dispatcher will be used to route event-messages.
     */
    private Cascade (final Dispatcher dispatcher)
<span class="fc" id="L60">    {</span>
<span class="fc" id="L61">        this.dispatcher = Objects.requireNonNull(dispatcher, &quot;dispatcher&quot;);</span>
<span class="fc" id="L62">        Verify.verify(isActive());</span>
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        Verify.verify(!isClosing());</span>
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">        Verify.verify(!isClosed());</span>
<span class="fc" id="L65">    }</span>

    /**
     * Factory method.
     *
     * @return a new instance of this class.
     */
    public static Cascade newCascade ()
    {
<span class="fc" id="L74">        final Dispatcher disp = Dispatcher.newDispatcher();</span>
<span class="fc" id="L75">        final Cascade cas = new Cascade(disp);</span>
<span class="fc" id="L76">        return cas;</span>
    }

    /**
     * Getter.
     *
     * @return a universally-unique-identifier of this object.
     */
    public UUID uuid ()
    {
<span class="fc" id="L86">        return uuid;</span>
    }

    /**
     * Setter.
     *
     * @param name will henceforth be the name of this cascade.
     * @return this.
     */
    public Cascade named (final String name)
    {
<span class="nc" id="L97">        this.name.set(Objects.requireNonNull(name, &quot;name&quot;));</span>
<span class="nc" id="L98">        return this;</span>
    }

    /**
     * Getter.
     *
     * &lt;p&gt;
     * By default, the name of this cascade is the string representation of the uuid().
     * &lt;/p&gt;
     *
     * @return the current name of this cascade.
     */
    public String name ()
    {
<span class="nc" id="L112">        return name.get();</span>
    }

    /**
     * Adds a new stage powered by a single thread.
     *
     * @return the given stage.
     */
    public CascadeStage newStage ()
    {
<span class="nc" id="L122">        return newStage(Executors.newFixedThreadPool(1)); // TODO</span>
    }

    /**
     * Adds a new stage powered by a pool of non-daemon worker threads.
     *
     * @param count is the number of threads in the pool.
     * @return the given stage.
     */
    public CascadeStage newStage (final int count)
    {
<span class="nc" id="L133">        final ThreadFactory factory = new ThreadFactoryBuilder().setDaemon(false).build();</span>
<span class="nc" id="L134">        final CascadeExecutor executor = PooledExecutor.create(factory, count);</span>
<span class="nc" id="L135">        return newStage(executor);</span>
    }

    /**
     * Adds a new stage powered by a given ExecutorService.
     *
     * &lt;p&gt;
     * The service can safely be shared with other stages.
     * When the last stage closes, the service will be shutdown.
     * &lt;/p&gt;
     *
     * @param service provides the power.
     * @return the new stage.
     */
    public CascadeStage newStage (final ExecutorService service)
    {
<span class="nc" id="L151">        return newStage(new ServiceExecutor(service));</span>
    }

    /**
     * Adds a new stage.
     *
     * @param executor will be used to power the new stage.
     * @return the given stage.
     */
    public synchronized CascadeStage newStage (final CascadeExecutor executor)
    {
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">        if (isClosing())</span>
        {
<span class="nc" id="L164">            throw new IllegalStateException(&quot;Already Closing!&quot;);</span>
        }

        /**
         * Prevent new stages from being created as we close the existing ones.
         */
<span class="fc" id="L170">        synchronized (lock)</span>
        {
<span class="fc" id="L172">            final CascadeStage stage = new CascadeStage(this, dispatcher, executor, s -&gt; removeStage(s));</span>

<span class="pc bpc" id="L174" title="1 of 2 branches missed.">            if (stage.isClosing())</span>
            {
<span class="nc" id="L176">                throw new IllegalArgumentException(&quot;The stage is already closing!&quot;);</span>
            }
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">            else if (stage.isClosed())</span>
            {
<span class="nc" id="L180">                throw new IllegalArgumentException(&quot;The stage is already closed!&quot;);</span>
            }
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">            else if (this.equals(stage.cascade()) == false)</span>
            {
<span class="nc" id="L184">                throw new IllegalArgumentException(&quot;The stage has a different cascade!&quot;);</span>
            }
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">            else if (stages.contains(stage))</span>
            {
<span class="nc" id="L188">                throw new IllegalStateException(&quot;The cascade already contains the given stage!&quot;);</span>
            }
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">            else if (close.get() == false)</span>
            {
<span class="fc" id="L192">                stages.add(stage);</span>
            }
            else
            {
<span class="nc" id="L196">                throw new IllegalStateException(&quot;The stage is already closing!&quot;);</span>
            }

<span class="fc" id="L199">            return stage;</span>
<span class="nc" id="L200">        }</span>
    }

    /**
     * Getter.
     *
     * @return all of the stages currently active in this cascade.
     */
    public Set&lt;CascadeStage&gt; stages ()
    {
<span class="fc" id="L210">        return ImmutableSet.copyOf(stages);</span>
    }

    /**
     * Getter.
     *
     * @return the event-channels that currently have at least one subscribed actor.
     */
    public Map&lt;CascadeToken, CascadeChannel&gt; channels ()
    {
<span class="nc" id="L220">        return dispatcher.channels();</span>
    }

    /**
     * Getter.
     *
     * @return true, if and only if, this cascade is not closed or closing.
     */
    public boolean isActive ()
    {
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">        return state.get() == ACTIVE;</span>
    }

    /**
     * Getter.
     *
     * @return true, if and only if, this cascade is closing.
     */
    public boolean isClosing ()
    {
<span class="fc bfc" id="L240" title="All 2 branches covered.">        return state.get() == CLOSING;</span>
    }

    /**
     * Getter.
     *
     * @return true, if and only, this cascade is now closed.
     */
    public boolean isClosed ()
    {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        return state.get() == CLOSED;</span>
    }

    /**
     * This method closes all of the stages and permanently terminates this cascade.
     *
     * &lt;p&gt;
     * This method returns immediately; however, the cascade will
     * not be closed until all stages therein close.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public Cascade close ()
    {
        /**
         * Prevent new stages from being created as we close the existing ones.
         */
<span class="fc" id="L268">        synchronized (lock)</span>
        {
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">            if (close.compareAndSet(false, true))</span>
            {
<span class="fc" id="L272">                state.set(CLOSING);</span>

<span class="fc bfc" id="L274" title="All 2 branches covered.">                for (CascadeStage stage : stages)</span>
                {
<span class="fc" id="L276">                    stage.close();</span>
<span class="fc" id="L277">                }</span>
            }
<span class="pc" id="L279">        }</span>

<span class="fc" id="L281">        return this;</span>
    }

    /**
     * This method blocks, until this cascade closes.
     *
     * &lt;p&gt;
     * This method does not cause the cascade to close.
     * Rather, this method merely causes the calling thread
     * to wait for the cascade to close.
     * &lt;/p&gt;
     *
     * @param timeout is the maximum amount of time to wait.
     * @return this.
     * @throws java.lang.InterruptedException
     */
    public Cascade awaitClose (final Duration timeout)
            throws InterruptedException
    {
<span class="fc" id="L300">        awaitCloseLatch.await(timeout.toNanos(), TimeUnit.NANOSECONDS);</span>
<span class="fc" id="L301">        return this;</span>
    }

    /**
     * This method retrieves the event-channel identified by the given token.
     *
     * @param event identifies the event-channel to find.
     * @return the channel, if it has at least one subscribed actor.
     */
    public Optional&lt;CascadeChannel&gt; channelOf (final CascadeToken event)
    {
<span class="nc" id="L312">        return dispatcher.lookup(event);</span>
    }

    /**
     * This method broadcasts an event-message.
     *
     * &lt;p&gt;
     * This method is a no-op, if no actors are subscribed
     * to receive event-messages from the given event-channel.
     * &lt;/p&gt;
     *
     * @param event identifies the event being produced.
     * @param stack contains the content of the message.
     * @return this.
     */
    public Cascade send (final CascadeToken event,
                         final CascadeStack stack)
    {
<span class="nc" id="L330">        final Optional&lt;CascadeChannel&gt; channel = channelOf(event);</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (channel.isPresent())</span>
        {
<span class="nc" id="L334">            channel.get().send(stack);</span>
        }

<span class="nc" id="L337">        return this;</span>
    }

    private synchronized void removeStage (final CascadeStage stage)
    {
<span class="fc" id="L342">        stages.remove(stage);</span>

<span class="pc bpc" id="L344" title="2 of 4 branches missed.">        if (stages.isEmpty() &amp;&amp; isClosing())</span>
        {
<span class="fc" id="L346">            state.set(CLOSED);</span>
<span class="fc" id="L347">            awaitCloseLatch.countDown();</span>
        }
<span class="fc" id="L349">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>