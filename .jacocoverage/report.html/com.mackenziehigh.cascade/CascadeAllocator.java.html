<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CascadeAllocator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade</a> &gt; <span class="el_source">CascadeAllocator.java</span></div><h1>CascadeAllocator.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade;

import com.google.common.base.Preconditions;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;
import com.google.common.primitives.Shorts;
import java.nio.charset.Charset;
import java.util.Map;
import java.util.OptionalLong;

/**
 * Use this interface to allocate operands.
 *
 * &lt;p&gt;
 * An operand is allocated within an allocation-pool,
 * which may recycle the operand when it is no longer in-use.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * In general, operands must be explicitly deallocated.
 * Operands use reference-counting in order to control deallocation.
 * When the reference-count reaches zero, the operand will be deallocated.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * An operand contains a reference to an operand &lt;i&gt;below&lt;/i&gt; it.
 * Therefore, operands form spaghetti-stack data-structures.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * Unless stated explicitly otherwise, all the methods defined herein,
 * including those in inner classes, are required to be thread-safe.
 * &lt;/p&gt;
 */
public interface CascadeAllocator
{
    /**
     * This type of exception means that an allocation failed,
     * because the relevant allocation-pool is full.
     */
    public class ExhaustedAllocationPoolException
            extends IllegalStateException
    {
        private final AllocationPool pool;

        public ExhaustedAllocationPoolException (final AllocationPool pool)
        {
<span class="fc" id="L48">            super(String.format(&quot;Allocation pool (%s) is completely full!&quot;, pool.name()));</span>
<span class="fc" id="L49">            this.pool = pool;</span>
<span class="fc" id="L50">        }</span>

        public AllocationPool getPool ()
        {
<span class="nc" id="L54">            return pool;</span>
        }
    }

    /**
     * This type of exception indicates that an operation cannot be performed,
     * because the underlying allocators differ.
     */
    public class AllocatorMismatchException
            extends RuntimeException
    {
        private final CascadeAllocator allocatorX;

        private final CascadeAllocator allocatorY;

        public AllocatorMismatchException (final CascadeAllocator allocatorX,
                                           final CascadeAllocator allocatorY)
        {
<span class="fc" id="L72">            super(String.format(&quot;Allocator Mismatch&quot;));</span>
<span class="fc" id="L73">            this.allocatorX = allocatorX;</span>
<span class="fc" id="L74">            this.allocatorY = allocatorY;</span>
<span class="fc" id="L75">        }</span>

        public CascadeAllocator getAllocatorX ()
        {
<span class="nc" id="L79">            return allocatorX;</span>
        }

        public CascadeAllocator getAllocatorY ()
        {
<span class="nc" id="L84">            return allocatorY;</span>
        }
    }

    /**
     * An instance of this interface describes a pool of allocations,
     * which may have specific finite user-defined bounds.
     */
    public interface AllocationPool
    {
        /**
         * Getter.
         *
         * @return the allocator that created this pool.
         */
        public CascadeAllocator allocator ();

        /**
         * Getter.
         *
         * @return the user-defined full-name of this pool.
         */
        public String name ();

        /**
         * Getter.
         *
         * @return the user-defined simple-name of this pool.
         */
        public String simpleName ();

        /**
         * Getter.
         *
         * @return true, if this pool is based on pre-allocated memory.
         */
        public boolean isFixed ();

        /**
         * Getter.
         *
         * &lt;p&gt;
         * This method only returns a value, if isFixed(),
         * because maintaining counts can be a performance hit
         * in some implementations due to thread contention.
         * Only the other hand, fixed pools must maintain
         * the counts anyway due to the recycling of operands.
         * &lt;/p&gt;
         *
         * @return the number of active allocations.
         */
        public default OptionalLong size ()
        {
<span class="fc" id="L137">            return OptionalLong.empty();</span>
        }

        /**
         * Getter.
         *
         * &lt;p&gt;
         * This method only returns a value, if isFixed(),
         * because maintaining counts can be a performance hit
         * in some implementations due to thread contention.
         * Only the other hand, fixed pools must maintain
         * the counts anyway due to the recycling of operands.
         * &lt;/p&gt;
         *
         * @return the maximum number of concurrent active allocations herein.
         */
        public default OptionalLong capacity ()
        {
<span class="fc" id="L155">            return OptionalLong.empty();</span>
        }

        /**
         * Getter.
         *
         * @return the minimum size of a single allocation.
         */
        public int minimumAllocationSize ();

        /**
         * Getter.
         *
         * @return the maximum size of a single allocation.
         */
        public int maximumAllocationSize ();

        /**
         * Use this method to allocate an operand.
         *
         * @param stack points to the top of the operand-stack that
         * the newly allocated operand will be pushed onto.
         * @param buffer contains the content of the operand.
         * @param offset is the start position of the data in the buffer.
         * @param length is the length of the data in the buffer.
         * @throws AllocatorMismatchException if stack was not created by this allocator.
         * @throws IllegalArgumentException if (offset + length) exceeds length(buffer).
         * @throws IllegalArgumentException if length is less than minimumAllocationSize().
         * @throws IllegalArgumentException if length is greater than maximumAllocationSize().
         * @throws ExhaustedAllocationPoolException if the pool is out-of-memory.
         */
        public default void alloc (final OperandStack stack,
                                   final byte[] buffer,
                                   final int offset,
                                   final int length)
        {
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (tryAlloc(stack, buffer, offset, length) == false)</span>
            {
<span class="fc" id="L193">                throw new ExhaustedAllocationPoolException(this);</span>
            }
<span class="fc" id="L195">        }</span>

        /**
         * Use this method to allocate an operand.
         *
         * &lt;p&gt;
         * The only difference between this method and alloc(*)
         * is that this method will return a boolean flag,
         * rather than throwing an exception, when an allocation
         * would fail due to pool/memory exhaustion.
         * &lt;/p&gt;
         *
         * @param stack points to the top of the operand-stack that
         * the newly allocated operand will be pushed onto.
         * @param buffer contains the content of the operand.
         * @param offset is the start position of the data in the buffer.
         * @param length is the length of the data in the buffer.
         * @return true, iff the allocation succeeds.
         * @throws AllocatorMismatchException if stack was not created by this allocator.
         * @throws IllegalArgumentException if (offset + length) exceeds length(buffer).
         * @throws IllegalArgumentException if length is less than minimumAllocationSize().
         * @throws IllegalArgumentException if length is greater than maximumAllocationSize().
         */
        public boolean tryAlloc (OperandStack stack,
                                 byte[] buffer,
                                 int offset,
                                 int length);
    }

    /**
     * An instance of this class is a space-efficient array of &lt;i&gt;pointers&lt;/i&gt; to operands.
     *
     * &lt;p&gt;
     * You must call close() in order to free the operands referenced by the array;
     * otherwise, a memory-leak will occur, because the operands may be pooled.
     * &lt;/p&gt;
     */
    public interface OperandArray
            extends AutoCloseable
    {
        /**
         * Getter.
         *
         * @return the allocator that created this pointer.
         */
        public CascadeAllocator allocator ();

        /**
         * Getter.
         *
         * @return the length of this array.
         */
        public int size ();

        /**
         * Use this method to assign an operand to an element in this array.
         *
         * @param index identifies the element to set.
         * @param value is the new value of the array element, or null, to clear the element.
         * @return this.
         * @throws AllocatorMismatchException if value was not created by this allocator.
         */
        public OperandArray set (int index,
                                 OperandStack value);

        /**
         * {@inheritDoc}
         */
        @Override
        public void close ();
    }

    /**
     * An instance of this class is a &lt;i&gt;pointer&lt;/i&gt; to an operand.
     *
     * &lt;p&gt;
     * An operand is actually the top element of a spaghetti-stack data-structure.
     * Thus, this object allows one to manipulate the stack by modifying the pointer.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Since this object is merely a pointer to an operand,
     * rather than the operand itself, two instances of this
     * interface may actually refer to the exact same operand.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * You must call close() in order to free the referenced operand-stack;
     * otherwise, a memory-leak will occur, because the operands may be pooled.
     * &lt;/p&gt;
     */
    public interface OperandStack
            extends AutoCloseable
    {
        /**
         * Getter.
         *
         * @return the allocator that created this pointer.
         */
        public CascadeAllocator allocator ();

        /**
         * Getter.
         *
         * @return the allocation-pool of the top operand on the operand-stack,
         * or the defaultPool(), if the stack is empty.
         */
        public AllocationPool pool ();

        /**
         * Use this method to cause this object to refer to a different operand-stack.
         *
         * @param value points to the other operand-stack.
         * @return this.
         * @throws AllocatorMismatchException if value was not created by this allocator.
         */
        public OperandStack set (OperandStack value);

        /**
         * Use this method to cause this object to refer to a different operand-stack.
         *
         * &lt;p&gt;
         * If the relevant array element is null,
         * then this method is equivalent to clear().
         * &lt;/p&gt;
         *
         * @param array contains the other operand-stack.
         * @param index identifies the relevant array element.
         * @return this.
         * @throws AllocatorMismatchException if array was not created by this allocator.
         * @throws IndexOutOfBoundsException if the index is too large or small.
         */
        public OperandStack set (OperandArray array,
                                 int index);

        /**
         * Copy this operand-stack.
         *
         * &lt;p&gt;
         * This is a constant-time operation.
         * &lt;/p&gt;
         *
         * @return a new operand-stack object.
         */
        public default OperandStack copy ()
        {
<span class="fc" id="L341">            final OperandStack retval = allocator().newOperandStack();</span>
<span class="fc" id="L342">            retval.set(this);</span>
<span class="fc" id="L343">            return retval;</span>
        }

        /**
         * Use this method to cause this method to no longer point to any operand-stack.
         * In other words, this pointer will become a null-pointer.
         * Here a null-pointer is equivalent to an empty operand-stack.
         *
         * @return this.
         */
        public default OperandStack clear ()
        {
<span class="fc" id="L355">            return set(null);</span>
        }

        /**
         * Equivalent: clear().
         */
        @Override
        public default void close ()
        {
<span class="fc" id="L364">            clear();</span>
<span class="fc" id="L365">        }</span>

        /**
         * Getter.
         *
         * @return the size of the top operand on the operand-stack in bytes.
         */
        public int operandSize ();

        /**
         * Getter.
         *
         * @return the maximum size of this operand in bytes.
         */
        public int operandCapacity ();

        /**
         * Getter.
         *
         * @return the number of operands that are on this operand-stack.
         */
        public int stackSize ();

        /**
         * Getter.
         *
         * @return true, iff the operandSize() is zero.
         */
        public default boolean isOperandEmpty ()
        {
<span class="fc bfc" id="L395" title="All 2 branches covered.">            return operandSize() == 0;</span>
        }

        /**
         * Getter.
         *
         * @return true, iff the stackSize() is zero.
         */
        public default boolean isStackEmpty ()
        {
<span class="fc bfc" id="L405" title="All 2 branches covered.">            return stackSize() == 0;</span>
        }

        /**
         * Copy an operand from the top of one operand-stack
         * onto the top of this operand-stack.
         *
         * @param value contains the operand to push.
         * @return this.
         * @throws NullPointerException if value is null.
         * @throws AllocatorMismatchException if value was not created by this allocator.
         * @throws IllegalArgumentException if value is empty.
         */
        public OperandStack push (OperandStack value);

        /**
         * Push an operand onto the top of the stack.
         *
         * &lt;p&gt;
         * True, becomes a single byte equal to one.
         * False, becomes a single byte equal to zero.
         * &lt;/p&gt;
         *
         * @param value is the operand to push.
         * @return this.
         */
        public default OperandStack push (boolean value)
        {
<span class="fc bfc" id="L433" title="All 2 branches covered.">            return push((byte) (value ? 1 : 0));</span>
        }

        /**
         * Push an operand onto the top of the stack.
         *
         * @param value is the operand to push.
         * @return this.
         */
        public default OperandStack push (byte value)
        {
<span class="fc" id="L444">            final byte[] array = new byte[1];</span>
<span class="fc" id="L445">            array[0] = value;</span>
<span class="fc" id="L446">            return push(array);</span>
        }

        /**
         * Push an operand onto the top of the stack.
         *
         * @param value is the operand to push.
         * @return this.
         */
        public default OperandStack push (short value)
        {
<span class="fc" id="L457">            return push(Shorts.toByteArray(value));</span>
        }

        /**
         * Push an operand onto the top of the stack.
         *
         * @param value is the operand to push.
         * @return this.
         */
        public default OperandStack push (int value)
        {
<span class="fc" id="L468">            return push(Ints.toByteArray(value));</span>
        }

        /**
         * Push an operand onto the top of the stack.
         *
         * @param value is the operand to push.
         * @return this.
         */
        public default OperandStack push (long value)
        {
<span class="fc" id="L479">            return push(Longs.toByteArray(value));</span>
        }

        /**
         * Push an operand onto the top of the stack.
         *
         * @param value is the operand to push.
         * @return this.
         */
        public default OperandStack push (float value)
        {
<span class="fc" id="L490">            return push(Float.floatToIntBits(value));</span>
        }

        /**
         * Push an operand onto the top of the stack.
         *
         * @param value is the operand to push.
         * @return this.
         */
        public default OperandStack push (double value)
        {
<span class="fc" id="L501">            return push(Longs.toByteArray(Double.doubleToLongBits(value)));</span>
        }

        /**
         * Push an operand onto the top of the stack.
         *
         * &lt;p&gt;
         * This method converts the string to a UTF-8
         * encoded byte-array and then pushes the array.
         * &lt;/p&gt;
         *
         * @param value is the operand to push.
         * @return this.
         */
        public default OperandStack push (String value)
        {
<span class="fc" id="L517">            Preconditions.checkNotNull(value, &quot;value&quot;);</span>
<span class="fc" id="L518">            return push(value.getBytes(Charset.forName(&quot;UTF-8&quot;)));</span>
        }

        /**
         * Push a operand onto the top of the stack.
         *
         * @param value is the operand to push.
         * @return this.
         */
        public default OperandStack push (byte[] value)
        {
<span class="fc" id="L529">            return push(value, 0, value.length);</span>
        }

        /**
         * Push a operand onto the top of the stack.
         *
         * @param buffer is the operand to push.
         * @param offset is the start location of the data in the buffer.
         * @param length is the length of the data.
         * @return this.
         * @throws IndexOutOfBoundsException if offset is less-than zero.
         * @throws IllegalArgumentException if length is less-than zero.
         */
        public default OperandStack push (byte[] buffer,
                                          int offset,
                                          int length)
        {
<span class="fc" id="L546">            allocator().defaultPool().alloc(this, buffer, offset, length);</span>
<span class="fc" id="L547">            return this;</span>
        }

        /**
         * Use this method to efficiently retrieve a
         * byte at a given index within this operand.
         *
         * @param index identifies the byte in this operand.
         * @return the byte at the given index.
         * @throws IndexOutOfBoundsException if index is invalid.
         * @throws IllegalStateException if stackSize() is zero.
         */
        public byte byteAt (int index);

        /**
         * Use this method to copy the content of this operand into a given buffer.
         *
         * @param buffer is the buffer that will receive the content.
         * @return the number of bytes copied into the buffer,
         * which may be less than operandSize(), if the buffer is too small.
         * @throws IndexOutOfBoundsException if index is invalid.
         * @throws IllegalStateException if stackSize() is zero.
         */
        public default int copyTo (byte[] buffer)
        {
<span class="fc" id="L572">            return copyTo(buffer, 0);</span>
        }

        /**
         * Use this method to copy the content of this operand into a given buffer,
         * starting at a given offset in the buffer.
         *
         * @param buffer is the buffer that will receive the content.
         * @param offset is an index into the buffer.
         * @return the number of bytes copied into the buffer,
         * which may be less than operandSize(), if the buffer is too small.
         * @throws IndexOutOfBoundsException if index is invalid.
         * @throws IllegalStateException if stackSize() is zero.
         */
        public default int copyTo (byte[] buffer,
                                   int offset)
        {
<span class="fc" id="L589">            return copyTo(buffer, offset, operandSize());</span>
        }

        /**
         * Use this method to copy the content of this operand into a given buffer,
         * starting at a given offset in the buffer.
         *
         * @param buffer is the buffer that will receive the content.
         * @param offset is an index into the buffer.
         * @param length is the maximum number of bytes to copy.
         * @return the number of bytes copied into the buffer,
         * which may be less than operandSize(), if the buffer is too small.
         * @throws IndexOutOfBoundsException if index is invalid.
         * @throws IllegalStateException if stackSize() is zero.
         */
        public int copyTo (byte[] buffer,
                           int offset,
                           int length);

        /**
         * Data Conversion: byte[] to boolean.
         *
         * @return the converted value.
         * @throws IllegalStateException if operandSize() &amp;ne (1).
         * @throws IllegalStateException if stackSize() is zero.
         */
        public default boolean asBoolean ()
        {
<span class="fc bfc" id="L617" title="All 2 branches covered.">            return asByte() != 0;</span>
        }

        /**
         * Data Conversion: byte[] to byte.
         *
         * @return the converted value.
         * @throws IllegalStateException if operandSize() &amp;ne (1).
         * @throws IllegalStateException if stackSize() is zero.
         */
        public default byte asByte ()
        {
<span class="fc bfc" id="L629" title="All 2 branches covered.">            Preconditions.checkState(operandSize() == 1, &quot;Wrong Size&quot;);</span>
<span class="fc" id="L630">            return byteAt(0);</span>
        }

        /**
         * Data Conversion: byte[] to short.
         *
         * &lt;p&gt;
         * The bytes must be in big-endian byte-order.
         * &lt;/p&gt;
         *
         * @return the converted value.
         * @throws IllegalStateException if operandSize() &amp;ne (2).
         * @throws IllegalStateException if stackSize() is zero.
         */
        public default short asShort ()
        {
<span class="fc bfc" id="L646" title="All 2 branches covered.">            Preconditions.checkState(operandSize() == 2, &quot;Wrong Size&quot;);</span>
<span class="fc" id="L647">            return Shorts.fromBytes(byteAt(0), byteAt(1));</span>
        }

        /**
         * Data Conversion: byte[] to int.
         *
         * &lt;p&gt;
         * The bytes must be in big-endian byte-order.
         * &lt;/p&gt;
         *
         * @return the converted value.
         * @throws IllegalStateException if operandSize() &amp;ne (4).
         * @throws IllegalStateException if stackSize() is zero.
         */
        public default int asInt ()
        {
<span class="fc bfc" id="L663" title="All 2 branches covered.">            Preconditions.checkState(operandSize() == 4, &quot;Wrong Size&quot;);</span>
<span class="fc" id="L664">            return Ints.fromBytes(byteAt(0),</span>
<span class="fc" id="L665">                                  byteAt(1),</span>
<span class="fc" id="L666">                                  byteAt(2),</span>
<span class="fc" id="L667">                                  byteAt(3));</span>
        }

        /**
         * Data Conversion: byte[] to long.
         *
         * &lt;p&gt;
         * The bytes must be in big-endian byte-order.
         * &lt;/p&gt;
         *
         * @return the converted value.
         * @throws IllegalStateException if operandSize() &amp;ne (8).
         * @throws IllegalStateException if stackSize() is zero.
         */
        public default long asLong ()
        {
<span class="fc bfc" id="L683" title="All 2 branches covered.">            Preconditions.checkState(operandSize() == 8, &quot;Wrong Size&quot;);</span>
<span class="fc" id="L684">            return Longs.fromBytes(byteAt(0),</span>
<span class="fc" id="L685">                                   byteAt(1),</span>
<span class="fc" id="L686">                                   byteAt(2),</span>
<span class="fc" id="L687">                                   byteAt(3),</span>
<span class="fc" id="L688">                                   byteAt(4),</span>
<span class="fc" id="L689">                                   byteAt(5),</span>
<span class="fc" id="L690">                                   byteAt(6),</span>
<span class="fc" id="L691">                                   byteAt(7));</span>
        }

        /**
         * Data Conversion: byte[] to float.
         *
         * @return the converted value.
         * @throws IllegalStateException if operandSize() &amp;ne (4).
         * @throws IllegalStateException if stackSize() is zero.
         */
        public default float asFloat ()
        {
<span class="fc bfc" id="L703" title="All 2 branches covered.">            Preconditions.checkState(operandSize() == 4, &quot;Wrong Size&quot;);</span>
<span class="fc" id="L704">            return Float.intBitsToFloat(asInt());</span>
        }

        /**
         * Data Conversion: byte[] to double.
         *
         * @return the converted value.
         * @throws IllegalStateException if operandSize() &amp;ne (8).
         * @throws IllegalStateException if stackSize() is zero.
         */
        public default double asDouble ()
        {
<span class="fc bfc" id="L716" title="All 2 branches covered.">            Preconditions.checkState(operandSize() == 8, &quot;Wrong Size&quot;);</span>
<span class="fc" id="L717">            return Double.longBitsToDouble(asLong());</span>
        }

        /**
         * Data Conversion: Encoded byte[] to String.
         *
         * &lt;p&gt;
         * The bytes must be UTF-8 encoded.
         * &lt;/p&gt;
         *
         * &lt;p&gt;
         * All of the bytes are considered to be part of the string.
         * No size header, etc, is present in the byte[].
         * &lt;/p&gt;
         *
         * @return the converted value.
         * @throws IllegalStateException if stackSize() is zero.
         */
        public default String asString ()
        {
<span class="fc" id="L737">            return new String(asByteArray(), Charset.forName(&quot;UTF-8&quot;));</span>
        }

        /**
         * Getter.
         *
         * @return the content of the top operand on the operand-stack.
         * @throws IllegalStateException if stackSize() is zero.
         */
        public default byte[] asByteArray ()
        {
<span class="fc" id="L748">            final byte[] array = new byte[operandSize()];</span>
<span class="fc" id="L749">            copyTo(array);</span>
<span class="fc" id="L750">            return array;</span>
        }

        /**
         * Pop a single operand off the top of the operand-stack.
         *
         * @return this.
         * @throws IllegalStateException if stackSize() is zero.
         */
        public OperandStack pop ();
    }

    /**
     * Getter.
     *
     * @return the system that this allocator is part of.
     */
    public Cascade cascade ();

    /**
     * Use this method to create a new operand-stack.
     *
     * @return a new empty operand-stack.
     */
    public OperandStack newOperandStack ();

    /**
     * Use this method to create a new operand-array.
     *
     * @param size is the length of the new array.
     * @return a new empty operand-array.
     * @throws IllegalArgumentException if size is less than zero.
     */
    public OperandArray newOperandArray (int size);

    /**
     * Getter.
     *
     * &lt;p&gt;
     * The map will include the default-pool.
     * &lt;/p&gt;
     *
     * @return a map that maps the full-names of pools to the pools themselves.
     */
    public Map&lt;String, AllocationPool&gt; pools ();

    /**
     * Getter.
     *
     * &lt;p&gt;
     * The name of the default-pool must be &quot;default&quot;.
     * &lt;/p&gt;
     *
     * @return the default-pool.
     * @throws IllegalStateException if no default pool exists.
     */
    public AllocationPool defaultPool ();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>