<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CascadeActor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade</a> &gt; <span class="el_source">CascadeActor.java</span></div><h1>CascadeActor.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableSet;
import com.mackenziehigh.cascade.internal.ArrayInflowQueue;
import com.mackenziehigh.cascade.internal.BoundedInflowQueue;
import com.mackenziehigh.cascade.internal.Dispatcher;
import com.mackenziehigh.cascade.internal.InflowQueue;
import com.mackenziehigh.cascade.internal.LinkedInflowQueue;
import com.mackenziehigh.cascade.internal.NotificationInflowQueue;
import com.mackenziehigh.cascade.internal.SwappableInflowQueue;
import com.mackenziehigh.cascade.internal.SynchronizedInflowQueue;
import java.time.Duration;
import java.util.Objects;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;

/**
 * Actors receive, process, and send event-messages.
 *
 * &lt;p&gt;
 * Actors are responsible for executing the onSetup(), onMessage(),
 * and onClose() handlers of the underlying script().
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * An actor will never execute the same script() concurrently.
 * Moreover, an actor will synchronize execution of the script()
 * in order to ensure memory-consistency.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * By default, actors use effectively unbounded linked inflow-queues.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * By default, actors use the Drop Incoming overflow-policy.
 * &lt;/p&gt;
 */
public final class CascadeActor
{
    /**
     * A builder that builds actor objects.
     */
    public interface Builder
    {
        /**
         * A factory that creates builders that build actor objects.
         *
         * @param &lt;T&gt; is the type of builder that will be created.
         */
        @FunctionalInterface
        public interface Factory&lt;T extends Builder&gt;
        {
            /**
             * Getter.
             *
             * @param stage will contain actors built via the builder.
             * @return the new builder.
             */
            public T newBuilder (CascadeStage stage);
        }

        /**
         * Getter.
         *
         * @return the stage that will contain the actor.
         */
        public CascadeStage stage ();

        /**
         * Getter.
         *
         * @return the newly built actor.
         */
        public CascadeActor build ();

        /**
         * Getter.
         *
         * @return the newly built and started actor.
         */
        public default CascadeActor buildAndStart ()
        {
<span class="nc" id="L93">            final CascadeActor actor = build();</span>
<span class="nc" id="L94">            actor.start();</span>
<span class="nc" id="L95">            return actor;</span>
        }
    }

    private static final int UNSTARTED = 0;

    private static final int STARTING = 1;

    private static final int ACTIVE = 2;

    private static final int CLOSING = 3;

    private static final int CLOSED = 4;

<span class="fc" id="L109">    private final CascadeActor SELF = this;</span>

    /**
     * This UUID uniquely identifies this actor.
     */
<span class="fc" id="L114">    private final UUID uuid = UUID.randomUUID();</span>

    /**
     * This is the name of this actor, which may change over time.
     */
<span class="fc" id="L119">    private volatile String name = uuid.toString();</span>

<span class="fc" id="L121">    private final AtomicInteger state = new AtomicInteger(UNSTARTED);</span>

    private final CascadeStage stage;

    private final Dispatcher dispatcher;

<span class="fc" id="L127">    private final CopyOnWriteArraySet&lt;CascadeToken&gt; subscriptions = new CopyOnWriteArraySet&lt;&gt;();</span>

<span class="fc" id="L129">    private final AtomicLong consumedMessageCount = new AtomicLong();</span>

<span class="fc" id="L131">    private final AtomicLong unhandledExceptionCount = new AtomicLong();</span>

    /**
     * True, if the script is executing.
     */
<span class="fc" id="L136">    private final AtomicBoolean acting = new AtomicBoolean(false);</span>

    /**
     * Used to implement awaitStart().
     */
<span class="fc" id="L141">    private final CountDownLatch awaitStartLatch = new CountDownLatch(1);</span>

    /**
     * Used to implement awaitClose().
     */
<span class="fc" id="L146">    private final CountDownLatch awaitCloseLatch = new CountDownLatch(1);</span>

    /**
     * The script will be passed this context in order to provide
     * the script with access to this actor and send messages.
     */
<span class="fc" id="L152">    private final CascadeContext context = () -&gt; SELF; // TODO: This is unclear.</span>

    /**
     * This script defines how this actor behaves.
     */
<span class="fc" id="L157">    private final CascadeScript script = new CascadeScript(context, unhandledExceptionCount);</span>

    /**
     * This inflow-queue physically stores the incoming event-messages.
     *
     * &lt;p&gt;
     * Whenever this field changes, the bounded-queue must change.
     * Moreover, the swappable-queue must delegate to the new bounded-queue.
     * &lt;/p&gt;
     */
    private volatile InflowQueue storageInflowQueue;

    /**
     * This inflow-queue is a facade around the storage-queue,
     * which implements the overflow policy of this actor.
     */
    private volatile BoundedInflowQueue boundedInflowQueue;

    /**
     * This inflow-queue is a facade around the bounded-queue,
     * which facilitates hot-swapping thereof.
     */
    private final SwappableInflowQueue swappableInflowQueue;

    /**
     * This inflow-queue is a facade around the swappable-queue,
     * which will invoke onQueueAdd() whenever a message is received.
     */
    private final NotificationInflowQueue schedulerInflowQueue;

    /**
     * This inflow-queue is a facade around the scheduler-queue,
     * which ensures that all operations are queue synchronized.
     */
    private final SynchronizedInflowQueue syncInflowQueue;

<span class="fc" id="L193">    private final AtomicReference&lt;CascadeToken&gt; event = new AtomicReference&lt;&gt;();</span>

<span class="fc" id="L195">    private final AtomicReference&lt;CascadeStack&gt; stack = new AtomicReference&lt;&gt;();</span>

    /**
     * This is a callback function that will cause this actor to
     * be scheduled for execution by the enclosing stage's executor.
     */
    private final Runnable scheduler;

    private final Consumer&lt;CascadeActor&gt; undertaker;

    /**
     * Sole Constructor.
     *
     * @param stage contains this actor.
     * @param undertaker will remove this actor from the stage, when the actor dies.
     */
    CascadeActor (final CascadeStage stage,
                  final Dispatcher dispatcher,
                  final Runnable scheduler,
                  final Consumer&lt;CascadeActor&gt; undertaker)
<span class="fc" id="L215">    {</span>
<span class="fc" id="L216">        this.stage = Objects.requireNonNull(stage, &quot;stage&quot;);</span>
<span class="fc" id="L217">        this.dispatcher = Objects.requireNonNull(dispatcher, &quot;dispatcher&quot;);</span>
<span class="fc" id="L218">        this.scheduler = Objects.requireNonNull(scheduler, &quot;scheduler&quot;);</span>
<span class="fc" id="L219">        this.undertaker = Objects.requireNonNull(undertaker, &quot;undertaker&quot;);</span>
<span class="fc" id="L220">        this.storageInflowQueue = new LinkedInflowQueue(Integer.MAX_VALUE);</span>
<span class="fc" id="L221">        this.boundedInflowQueue = new BoundedInflowQueue(BoundedInflowQueue.OverflowPolicy.DROP_INCOMING, storageInflowQueue);</span>
<span class="fc" id="L222">        this.swappableInflowQueue = new SwappableInflowQueue(boundedInflowQueue);</span>
<span class="fc" id="L223">        this.schedulerInflowQueue = new NotificationInflowQueue(swappableInflowQueue, q -&gt; onQueueAdd(q));</span>
<span class="fc" id="L224">        this.syncInflowQueue = new SynchronizedInflowQueue(schedulerInflowQueue);</span>
<span class="fc" id="L225">    }</span>

    /**
     * Setter.
     *
     * @param name will henceforth be the name of this actor.
     * @return this.
     */
    public CascadeActor named (final String name)
    {
<span class="nc" id="L235">        this.name = Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="nc" id="L236">        return this;</span>
    }

    /**
     * Getter.
     *
     * &lt;p&gt;
     * By default, the name of this actor is the string representation of the actor's UUID.
     * &lt;/p&gt;
     *
     * @return the current name of this actor.
     */
    public String name ()
    {
<span class="fc" id="L250">        return name;</span>
    }

    /**
     * Getter.
     *
     * @return a UUID that uniquely identifies this actor in time and space.
     */
    public UUID uuid ()
    {
<span class="fc" id="L260">        return uuid;</span>
    }

    /**
     * Getter.
     *
     * @return the enclosing cascade.
     */
    public Cascade cascade ()
    {
<span class="fc" id="L270">        return stage().cascade();</span>
    }

    /**
     * Getter.
     *
     * @return the enclosing stage.
     */
    public CascadeStage stage ()
    {
<span class="fc" id="L280">        return stage;</span>
    }

    /**
     * Getter.
     *
     * @return the script that will be executed whenever messages are received.
     */
    public CascadeScript script ()
    {
<span class="fc" id="L290">        return script;</span>
    }

    /**
     * Causes this actor to switch to a fixed-size array-based
     * inflow-queue, which will be used to store the messages
     * that are pending processing by this actor.
     *
     * &lt;p&gt;
     * When backlogSize() reaches backlogCapacity().
     * the overflow-policy will dictate what happens
     * when new messages arrive for this actor.
     * &lt;/p&gt;
     *
     * @param capacity will be the backlogCapacity() of the queue.
     * @return this.
     */
    public CascadeActor useArrayInflowQueue (final int capacity)
    {
<span class="nc" id="L309">        final BoundedInflowQueue.OverflowPolicy policy = boundedInflowQueue.policy();</span>
<span class="nc" id="L310">        final InflowQueue newQueue = new ArrayInflowQueue(capacity);</span>
<span class="nc" id="L311">        replaceQueue(policy, newQueue);</span>
<span class="nc" id="L312">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using an array-based inflow-queue.
     */
    public boolean hasArrayInflowQueue ()
    {
<span class="fc" id="L322">        return storageInflowQueue instanceof ArrayInflowQueue;</span>
    }

    /**
     * Causes this actor to switch to an fixed-size array-based
     * inflow-queue, which will be used to store the messages
     * that are pending processing by this actor.
     *
     * &lt;p&gt;
     * When backlogSize() reaches backlogCapacity().
     * the overflow-policy will dictate what happens
     * when new messages arrive for this actor.
     * &lt;/p&gt;
     *
     * @param capacity will be the backlogCapacity() of the queue.
     * @return this.
     */
    public CascadeActor useLinkedInflowQueue (final int capacity)
    {
<span class="nc" id="L341">        final BoundedInflowQueue.OverflowPolicy policy = boundedInflowQueue.policy();</span>
<span class="nc" id="L342">        final InflowQueue newQueue = new LinkedInflowQueue(capacity);</span>
<span class="nc" id="L343">        replaceQueue(policy, newQueue);</span>
<span class="nc" id="L344">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using a linked-list based inflow-queue.
     */
    public boolean hasLinkedInflowQueue ()
    {
<span class="fc" id="L354">        return storageInflowQueue instanceof LinkedInflowQueue;</span>
    }

    /**
     * Causes the overflow-policy to be changed to Drop All.
     *
     * &lt;p&gt;
     * After this method returns, whenever backlogSize() reaches
     * backlogCapacity() and a new message arrives for processing
     * by this actor, the inflow-queue will be cleared
     * and the new message will also be dropped.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor useOverflowPolicyDropAll ()
    {
<span class="nc" id="L371">        replaceQueue(BoundedInflowQueue.OverflowPolicy.DROP_ALL, storageInflowQueue);</span>
<span class="nc" id="L372">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using the Drop All overflow-policy.
     */
    public boolean isOverflowPolicyDropAll ()
    {
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">        return boundedInflowQueue.policy() == BoundedInflowQueue.OverflowPolicy.DROP_ALL;</span>
    }

    /**
     * Causes the overflow-policy to be changed to Drop Pending.
     *
     * &lt;p&gt;
     * After this method returns, whenever backlogSize() reaches
     * backlogCapacity() and a new message arrives for processing
     * by this actor, the inflow-queue will be cleared and then
     * the new message will be enqueued.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor useOverflowPolicyDropPending ()
    {
<span class="nc" id="L399">        replaceQueue(BoundedInflowQueue.OverflowPolicy.DROP_PENDING, storageInflowQueue);</span>
<span class="nc" id="L400">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using the Drop Pending overflow-policy.
     */
    public boolean isOverflowPolicyDropPending ()
    {
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">        return boundedInflowQueue.policy() == BoundedInflowQueue.OverflowPolicy.DROP_PENDING;</span>
    }

    /**
     * Causes the overflow-policy to be changed to Drop Oldest.
     *
     * &lt;p&gt;
     * After this method returns, whenever backlogSize() reaches
     * backlogCapacity() and a new message arrives for processing
     * by this actor, the message that has been in the inflow-queue
     * for the longest period of time will be removed and then
     * the new message will be enqueued.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor useOverflowPolicyDropOldest ()
    {
<span class="nc" id="L428">        replaceQueue(BoundedInflowQueue.OverflowPolicy.DROP_OLDEST, storageInflowQueue);</span>
<span class="nc" id="L429">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using the Drop Oldest overflow-policy.
     */
    public boolean isOverflowPolicyDropOldest ()
    {
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        return boundedInflowQueue.policy() == BoundedInflowQueue.OverflowPolicy.DROP_OLDEST;</span>
    }

    /**
     * Causes the overflow-policy to be changed to Drop Newest.
     *
     * &lt;p&gt;
     * After this method returns, whenever backlogSize() reaches
     * backlogCapacity() and a new message arrives for processing
     * by this actor, the message that has been in the inflow-queue
     * for the shortest period of time will be removed and then
     * the new message will be enqueued.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor useOverflowPolicyDropNewest ()
    {
<span class="nc" id="L457">        replaceQueue(BoundedInflowQueue.OverflowPolicy.DROP_NEWEST, storageInflowQueue);</span>
<span class="nc" id="L458">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using the Drop Newest overflow-policy.
     */
    public boolean isOverflowPolicyDropNewest ()
    {
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        return boundedInflowQueue.policy() == BoundedInflowQueue.OverflowPolicy.DROP_NEWEST;</span>
    }

    /**
     * Causes the overflow-policy to be changed to Drop Incoming.
     *
     * &lt;p&gt;
     * After this method returns, whenever backlogSize() reaches
     * backlogCapacity() and a new message arrives for processing
     * by this actor, the message that has just arrived will be
     * dropped and no message will be enqueued. In short, messages
     * will only be enqueued when there is actually space available.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor useOverflowPolicyDropIncoming ()
    {
<span class="nc" id="L486">        replaceQueue(BoundedInflowQueue.OverflowPolicy.DROP_INCOMING, storageInflowQueue);</span>
<span class="nc" id="L487">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using the Drop Incoming overflow-policy.
     */
    public boolean isOverflowPolicyDropIncoming ()
    {
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">        return boundedInflowQueue.policy() == BoundedInflowQueue.OverflowPolicy.DROP_INCOMING;</span>
    }

    /**
     * This method causes this actor to begin receiving messages for the given event.
     *
     * @param event identifies the event to listen for.
     * @return this.
     */
    public CascadeActor subscribe (final CascadeToken event)
    {
<span class="fc" id="L508">        subscriptions.add(event);</span>
<span class="fc" id="L509">        dispatcher.subscribe(event, this);</span>
<span class="fc" id="L510">        return this;</span>
    }

    /**
     * This method causes this actor to stop receiving messages for the given event.
     *
     * &lt;p&gt;
     * If this actor is not currently subscribed to the given event,
     * then this method is simply a no-op.
     * &lt;/p&gt;
     *
     * @param event identifies the event to no longer listen for.
     * @return this.
     */
    public CascadeActor unsubscribe (final CascadeToken event)
    {
<span class="fc" id="L526">        dispatcher.unsubscribe(event, this);</span>
<span class="fc" id="L527">        subscriptions.remove(event);</span>
<span class="fc" id="L528">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return the identities of the events that this actor is listening for.
     */
    public Set&lt;CascadeToken&gt; subscriptions ()
    {
<span class="fc" id="L538">        return ImmutableSet.copyOf(subscriptions);</span>
    }

    /**
     * Getter.
     *
     * @return true, if and only if, startup is in-progress.
     */
    public boolean isStarting ()
    {
<span class="fc bfc" id="L548" title="All 2 branches covered.">        return state.get() == STARTING;</span>
    }

    /**
     * Getter.
     *
     * @return true, if and only if, startup has completed.
     */
    public boolean isStarted ()
    {
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">        return state.get() &gt; STARTING;</span>
    }

    /**
     * Getter.
     *
     * @return true, if and only if, the script() is currently being executed.
     */
    public boolean isActing ()
    {
<span class="fc" id="L568">        return acting.get();</span>
    }

    /**
     * Getter.
     *
     * @return true, if and only if, this actor is not unstarted, closed, or closing.
     */
    public boolean isActive ()
    {
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">        return state.get() == ACTIVE;</span>
    }

    /**
     * Getter.
     *
     * @return true, if and only if, this actor is leaving the stage.
     */
    public boolean isClosing ()
    {
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">        return state.get() == CLOSING;</span>
    }

    /**
     * Getter.
     *
     * @return true, if and only if, this actor has left the stage.
     */
    public boolean isClosed ()
    {
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">        return state.get() == CLOSED;</span>
    }

    /**
     * Getter.
     *
     * @return the current number of messages enqueued in the inflow queue.
     */
    public int backlogSize ()
    {
<span class="fc" id="L608">        return syncInflowQueue.size();</span>
    }

    /**
     * Getter.
     *
     * @return the current capacity of the inflow queue.
     */
    public int backlogCapacity ()
    {
<span class="fc" id="L618">        return syncInflowQueue.capacity();</span>
    }

    /**
     * Getter.
     *
     * @return the total number of messages sent to this actor, thus far,
     * that were enqueued without being immediately dropped.
     */
    public long acceptedMessages ()
    {
<span class="fc" id="L629">        return boundedInflowQueue.accepted(); // Thread-Safe</span>
    }

    /**
     * Getter.
     *
     * @return the total number of messages that this actor
     * has dropped upon receiving them, thus far.
     */
    public long droppedMessages ()
    {
<span class="fc" id="L640">        return boundedInflowQueue.dropped(); // Thread-Safe</span>
    }

    /**
     * Getter.
     *
     * @return the total number of messages that this actor
     * has actually processed using the script(), thus far.
     */
    public long consumedMessages ()
    {
<span class="fc" id="L651">        return consumedMessageCount.get();</span>
    }

    /**
     * Getter.
     *
     * @return the number of unhandled exceptions that
     * have been thrown by the script(), thus far.
     */
    public long unhandledExceptions ()
    {
<span class="fc" id="L662">        return unhandledExceptionCount.get();</span>
    }

    /**
     * Getter.
     *
     * @return the context that is passed to the script()
     * whenever messages are processed by this actor.
     */
    public CascadeContext context ()
    {
<span class="fc" id="L673">        return context;</span>
    }

    /**
     * Sends an event-message directly to this actor.
     *
     * &lt;p&gt;
     * The event-message will *not* be routed through the global dispatcher;
     * therefore, no other actors will receive the event-message,
     * even if they are subscribed to the same event.
     * &lt;/p&gt;
     *
     * @param event identifies the event that produced the event-message.
     * @param stack is the content of the event-message.
     * @return this.
     */
    public CascadeActor tell (final CascadeToken event,
                              final CascadeStack stack)
    {
<span class="fc" id="L692">        Preconditions.checkNotNull(event, &quot;event&quot;);</span>
<span class="fc" id="L693">        Preconditions.checkNotNull(stack, &quot;stack&quot;);</span>
<span class="fc" id="L694">        syncInflowQueue.offer(event, stack);</span>
<span class="fc" id="L695">        return this;</span>
    }

    /**
     * Schedule this actor for startup.
     *
     * @return this.
     */
    public CascadeActor start ()
    {
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">        if (state.compareAndSet(UNSTARTED, STARTING))</span>
        {
<span class="fc" id="L707">            scheduler.run();</span>
        }
<span class="fc" id="L709">        return this;</span>
    }

    /**
     * Cause this actor to perform one unit-of-work and then return.
     *
     * &lt;p&gt;
     * A single unit-of-work is either executing the startup-script,
     * processing a single incoming message using the message
     * handling script, or executing the stop-script.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Only one unit-of-work is performed during each invocation
     * in order to implement cooperative multi-tasking.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If no work is immediately available, then this method is a no-op.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor perform ()
    {
<span class="fc" id="L734">        synchronized (this)</span>
        {
            try
            {
<span class="fc" id="L738">                setupIfNeeded();</span>
            }
<span class="nc" id="L740">            catch (Throwable ex)</span>
            {
                //reportUnhandledException(ex);
<span class="nc" id="L743">                close();</span>
<span class="nc" id="L744">                return this;</span>
<span class="fc" id="L745">            }</span>

            try
            {
<span class="fc" id="L749">                processMessageIfNeeded();</span>
            }
<span class="nc" id="L751">            catch (Throwable ex)</span>
            {
                //reportUnhandledException(ex);
<span class="fc" id="L754">            }</span>

            try
            {
<span class="fc" id="L758">                shutdownIfNeeded();</span>
            }
<span class="nc" id="L760">            catch (Throwable ex)</span>
            {
                //reportUnhandledException(ex);
<span class="fc" id="L763">            }</span>
<span class="pc" id="L764">        }</span>

<span class="fc" id="L766">        return this;</span>
    }

    /**
     * This method kills this actor, which causes it to stop listening
     * for incoming messages, remove itself from the stage, etc.
     *
     * &lt;p&gt;
     * This method returns immediately; however, the actor will not close
     * until it has finished any work that it is currently performing.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor close ()
    {
        // TODO: other states?
<span class="nc bnc" id="L783" title="All 4 branches missed.">        if (state.compareAndSet(ACTIVE, CLOSING) || state.compareAndSet(UNSTARTED, CLOSING))</span>
        {
<span class="nc" id="L785">            scheduler.run();</span>
        }
<span class="nc" id="L787">        return this;</span>
    }

    /**
     * This method blocks, until this actor starts.
     *
     * &lt;p&gt;
     * If this actor already started, then this method is a no-op.
     * &lt;/p&gt;
     *
     * @param timeout is the maximum amount of time to wait.
     * @return this.
     * @throws java.lang.InterruptedException
     */
    public CascadeActor awaitStart (final Duration timeout)
            throws InterruptedException
    {
<span class="nc" id="L804">        final long nanos = timeout.toNanos();</span>
<span class="nc" id="L805">        awaitStartLatch.await(nanos, TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L806">        return this; // TODO: boolean instead?</span>
    }

    /**
     * This method blocks, until this actor dies.
     *
     * &lt;p&gt;
     * If this actor already closed, then this method is a no-op.
     * &lt;/p&gt;
     *
     * @param timeout is the maximum amount of time to wait.
     * @return this.
     * @throws java.lang.InterruptedException
     */
    public CascadeActor awaitClose (final Duration timeout)
            throws InterruptedException
    {
<span class="nc" id="L823">        awaitCloseLatch.await(timeout.toNanos(), TimeUnit.NANOSECONDS);</span>
<span class="nc" id="L824">        return this; // TODO: boolean instead?</span>
    }

    private void setupIfNeeded ()
            throws Throwable
    {
<span class="fc bfc" id="L830" title="All 2 branches covered.">        if (isStarting())</span>
        {
            try
            {
<span class="fc" id="L834">                script.onSetup(context);</span>
            }
            finally
            {
<span class="pc" id="L838">                state.set(ACTIVE);</span>
<span class="pc" id="L839">                awaitStartLatch.countDown();</span>
<span class="fc" id="L840">            }</span>
        }
<span class="fc" id="L842">    }</span>

    private void processMessageIfNeeded ()
            throws Throwable
    {
<span class="fc" id="L847">        event.set(null);</span>
<span class="fc" id="L848">        stack.set(null);</span>
<span class="fc" id="L849">        syncInflowQueue.removeOldest(event, stack);</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">        final boolean delivered = event.get() != null; // Not Always True (Overflow Effects)</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">        if (delivered)</span>
        {
<span class="fc" id="L853">            consumedMessageCount.incrementAndGet();</span>
<span class="fc" id="L854">            script.onMessage(context(), event.get(), stack.get());</span>
        }
<span class="fc" id="L856">    }</span>

    private void shutdownIfNeeded ()
            throws Throwable
    {
<span class="pc bpc" id="L861" title="1 of 2 branches missed.">        if (isClosing())</span>
        {
            try
            {
<span class="nc" id="L865">                script().onClose(context);</span>
            }
            finally
            {
<span class="nc" id="L869">                state.set(CLOSED);</span>
<span class="nc" id="L870">                undertaker.accept(this);</span>
<span class="nc" id="L871">            }</span>
        }
<span class="fc" id="L873">    }</span>

    /**
     * This method will be executed whenever an event-message is received,
     * even if the message is ultimately dropped by this actor.
     *
     * @param queue just received the new message.
     */
    private void onQueueAdd (final InflowQueue queue)
    {

<span class="fc" id="L884">        scheduler.run();</span>
<span class="fc" id="L885">    }</span>

    private void replaceQueue (final BoundedInflowQueue.OverflowPolicy policy,
                               final InflowQueue newStorageQueue)
    {
<span class="nc" id="L890">        final Runnable action = () -&gt;</span>
        {
<span class="nc" id="L892">            storageInflowQueue = newStorageQueue;</span>
<span class="nc" id="L893">            boundedInflowQueue = new BoundedInflowQueue(policy, newStorageQueue);</span>
<span class="nc" id="L894">            swappableInflowQueue.replaceDelegate(boundedInflowQueue);</span>
<span class="nc" id="L895">        };</span>

        /**
         * The replacement must be synchronized with regard to other queue operations.
         */
<span class="nc" id="L900">        syncInflowQueue.sync(action);</span>
<span class="nc" id="L901">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>