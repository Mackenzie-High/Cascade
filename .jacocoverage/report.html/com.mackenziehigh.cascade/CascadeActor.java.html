<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CascadeActor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCoverage analysis of project &quot;Cascade&quot; (powered by JaCoCo from EclEmma)</a> &gt; <a href="index.source.html" class="el_package">com.mackenziehigh.cascade</a> &gt; <span class="el_source">CascadeActor.java</span></div><h1>CascadeActor.java</h1><pre class="source lang-java linenums">package com.mackenziehigh.cascade;

import com.google.common.base.Preconditions;
import com.google.common.base.Verify;
import com.google.common.collect.ImmutableSet;
import com.mackenziehigh.cascade.internal.ArrayInflowQueue;
import com.mackenziehigh.cascade.internal.BoundedInflowQueue;
import com.mackenziehigh.cascade.internal.Dispatcher;
import com.mackenziehigh.cascade.internal.InflowQueue;
import com.mackenziehigh.cascade.internal.LinkedInflowQueue;
import com.mackenziehigh.cascade.internal.NotificationInflowQueue;
import com.mackenziehigh.cascade.internal.SwappableInflowQueue;
import com.mackenziehigh.cascade.internal.SynchronizedInflowQueue;
import java.time.Duration;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Actors send, receive, and process event-messages.
 *
 * &lt;p&gt;
 * Actors are responsible for executing the onSetup(), onMessage(),
 * and onClose() handlers of the underlying script().
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * An actor will never execute the same script() concurrently.
 * Moreover, an actor will synchronize execution of the script()
 * in order to ensure memory-consistency.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * By default, actors use effectively unbounded linked inflow-queues.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * By default, actors use the Drop Incoming overflow-policy.
 * &lt;/p&gt;
 */
public final class CascadeActor
{
    /**
     * A builder that builds actor objects.
     */
    public interface Builder
    {
        /**
         * A factory that creates builders that build actor objects.
         *
         * @param &lt;T&gt; is the type of builder that will be created.
         */
        @FunctionalInterface
        public interface Factory&lt;T extends Builder&gt;
        {
            /**
             * Getter.
             *
             * @param stage will contain actors built via the builder.
             * @return the new builder.
             */
            public T newBuilder (CascadeStage stage);
        }

        /**
         * Getter.
         *
         * @return the stage that will contain the actor.
         */
        public CascadeStage stage ();

        /**
         * Getter.
         *
         * @return the newly built actor.
         */
        public CascadeActor build ();

        /**
         * Getter.
         *
         * @return the newly built and started actor.
         */
        public default CascadeActor buildAndStart ()
        {
<span class="nc" id="L96">            final CascadeActor actor = build();</span>
<span class="nc" id="L97">            actor.start();</span>
<span class="nc" id="L98">            return actor;</span>
        }
    }

    /**
     * The life-cycle phases of an actor in chronological order.
     */
<span class="pc" id="L105">    public enum ActorLifeCycle</span>
    {
        /**
         * The actor has been created, but start() has not yet been called.
         */
<span class="fc" id="L110">        EGG,</span>

        /**
         * start() was just called, but the setup script has not yet finished.
         */
<span class="fc" id="L115">        STARTING,</span>
        /**
         * Setup is complete and the actor is ready to process messages.
         */
<span class="fc" id="L119">        ACTIVE,</span>
        /**
         * close() was just called, but the close script has not yet finished.
         */
<span class="fc" id="L123">        CLOSING,</span>
        /**
         * The close script has completed after the call to close().
         */
<span class="fc" id="L127">        DEAD</span>
    }

    /**
     * Performance metrics related to this actor.
     */
    public final class ActorMetrics
    {
        private ActorMetrics ()
<span class="fc" id="L136">        {</span>
            // Pass
<span class="fc" id="L138">        }</span>

        /**
         * Getter.
         *
         * @return the current number of messages enqueued in the inflow queue.
         */
        public int getBacklogSize ()
        {
<span class="fc" id="L147">            return syncInflowQueue.size();</span>
        }

        /**
         * Getter.
         *
         * @return the current capacity of the inflow queue.
         */
        public int getBacklogCapacity ()
        {
<span class="fc" id="L157">            return syncInflowQueue.capacity();</span>
        }

        /**
         * Getter.
         *
         * @return the total number of messages sent to this actor.
         */
        public long getOfferedMessageCount ()
        {
<span class="fc" id="L167">            return boundedInflowQueue.offered();</span>
        }

        /**
         * Getter.
         *
         * @return the total number of messages sent to this actor, thus far,
         * that were enqueued without being immediately dropped.
         */
        public long getAcceptedMessageCount ()
        {
<span class="fc" id="L178">            return boundedInflowQueue.accepted(); // Thread-Safe</span>
        }

        /**
         * Getter.
         *
         * @return the total number of messages that this actor
         * has dropped upon receiving them, thus far.
         */
        public long getDroppedMessageCount ()
        {
<span class="fc" id="L189">            return boundedInflowQueue.dropped(); // Thread-Safe</span>
        }

        /**
         * Getter.
         *
         * @return the total number of messages that this actor
         * has actually processed using the script(), thus far.
         */
        public long getConsumedMessageCount ()
        {
<span class="fc" id="L200">            return consumedMessageCount.get();</span>
        }

        /**
         * Getter.
         *
         * @return the number of unhandled exceptions that
         * have been thrown by the script(), thus far.
         */
        public long getUnhandledExceptionCount ()
        {
<span class="fc" id="L211">            return unhandledExceptionCount.get();</span>
        }

        /**
         * Getter.
         *
         * @return the last unhandled exception, if any.
         */
        public Optional&lt;Throwable&gt; getLastUnhandledException ()
        {
<span class="nc" id="L221">            return Optional.empty(); // TODO</span>
        }
    }

<span class="fc" id="L225">    private final CascadeActor SELF = this;</span>

    /**
     * This UUID uniquely identifies this actor.
     */
<span class="fc" id="L230">    private final UUID uuid = UUID.randomUUID();</span>

    /**
     * This is the name of this actor, which may change over time.
     */
<span class="fc" id="L235">    private volatile String name = uuid.toString();</span>

    /**
     * This is the life-cycle phase that this actor is currently in.
     */
<span class="fc" id="L240">    private final AtomicReference&lt;ActorLifeCycle&gt; phase = new AtomicReference&lt;&gt;(ActorLifeCycle.EGG);</span>

    /**
     * This stage contains this actor.
     */
    private final CascadeStage stage;

    /**
     * This object routes messages to-and-from this actor.
     */
    private final Dispatcher dispatcher;

    /**
     * These identify the event-channels that this actor is currently subscribed-to.
     */
<span class="fc" id="L255">    private final CopyOnWriteArraySet&lt;CascadeToken&gt; subscriptions = new CopyOnWriteArraySet&lt;&gt;();</span>

    /**
     * This is how many messages have been processed by this actor thus far.
     */
<span class="fc" id="L260">    private final AtomicLong consumedMessageCount = new AtomicLong();</span>

    /**
     * This is how many unhandled-exceptions were thrown thus far.
     */
<span class="fc" id="L265">    private final AtomicLong unhandledExceptionCount = new AtomicLong();</span>

    /**
     * True, if the script is executing at this very moment.
     */
<span class="fc" id="L270">    private final AtomicBoolean acting = new AtomicBoolean(false);</span>

    /**
     * Used to implement await(). No latch is needed for the first phase.
     */
<span class="fc" id="L275">    private final CountDownLatch[] awaitLatches = new CountDownLatch[ActorLifeCycle.values().length - 1];</span>

    /**
     * The script will be passed this context in order to provide
     * the script with access to this actor and send messages.
     */
<span class="fc" id="L281">    private final CascadeContext context = () -&gt; SELF; // TODO: This is unclear.</span>

    /**
     * This script defines how this actor behaves.
     */
<span class="fc" id="L286">    private final CascadeScript script = new CascadeScript(context, unhandledExceptionCount);</span>

    /**
     * This inflow-queue physically stores the incoming event-messages.
     *
     * &lt;p&gt;
     * Whenever this field changes, the bounded-queue must change.
     * Moreover, the swappable-queue must delegate to the new bounded-queue.
     * &lt;/p&gt;
     */
    private volatile InflowQueue storageInflowQueue;

    /**
     * This inflow-queue is a facade around the storage-queue,
     * which implements the overflow policy of this actor.
     */
    private volatile BoundedInflowQueue boundedInflowQueue;

    /**
     * This inflow-queue is a facade around the bounded-queue,
     * which facilitates hot-swapping thereof.
     */
    private final SwappableInflowQueue swappableInflowQueue;

    /**
     * This inflow-queue is a facade around the swappable-queue,
     * which will invoke onQueueAdd() whenever a message is received.
     */
    private final NotificationInflowQueue schedulerInflowQueue;

    /**
     * This inflow-queue is a facade around the scheduler-queue,
     * which ensures that all operations are queue synchronized.
     */
    private final SynchronizedInflowQueue syncInflowQueue;

    /**
     * This object provides the power to this actor, as needed.
     */
    private volatile CascadePowerSource executor;

    /**
     * This is how many tasks are pending for this actor to perform,
     * which may include startup tasks, shutdown tasks, or pending messages.
     */
<span class="fc" id="L331">    private final AtomicLong pendingTasks = new AtomicLong();</span>

    /**
     * The executor is free to use this object to store actor-specific data,
     * for its own personal benefit, such as scheduling.
     */
<span class="fc" id="L337">    private final AtomicReference&lt;?&gt; pocket = new AtomicReference&lt;&gt;();</span>

    /**
     * When invoked, this consumer will remove this actor from the enclosing stage.
     */
    private final Consumer&lt;CascadeActor&gt; undertaker;

    /**
     * These are the performance metrics pertaining to this actor.
     */
<span class="fc" id="L347">    private final ActorMetrics metrics = new ActorMetrics();</span>

    /**
     * This is needed to dequeue messages from the inflow-queue.
     * Caching the AtomicReference avoids the need to allocate it each time.
     */
<span class="fc" id="L353">    private final AtomicReference&lt;CascadeToken&gt; event = new AtomicReference&lt;&gt;();</span>

    /**
     * This is needed to dequeue messages from the inflow-queue.
     * Caching the AtomicReference avoids the need to allocate it each time.
     */
<span class="fc" id="L359">    private final AtomicReference&lt;CascadeStack&gt; stack = new AtomicReference&lt;&gt;();</span>

    /**
     * Sole Constructor.
     *
     * @param stage contains this actor.
     * @param undertaker will remove this actor from the stage, when the actor dies.
     */
    CascadeActor (final CascadeStage stage,
                  final Dispatcher dispatcher,
                  final CascadePowerSource executor,
                  final Consumer&lt;CascadeActor&gt; undertaker)
<span class="fc" id="L371">    {</span>
<span class="fc" id="L372">        this.stage = Objects.requireNonNull(stage, &quot;stage&quot;);</span>
<span class="fc" id="L373">        this.dispatcher = Objects.requireNonNull(dispatcher, &quot;dispatcher&quot;);</span>
<span class="fc" id="L374">        this.executor = Objects.requireNonNull(executor, &quot;executor&quot;);</span>
<span class="fc" id="L375">        this.undertaker = Objects.requireNonNull(undertaker, &quot;undertaker&quot;);</span>
<span class="fc" id="L376">        this.storageInflowQueue = new LinkedInflowQueue(Integer.MAX_VALUE);</span>
<span class="fc" id="L377">        this.boundedInflowQueue = new BoundedInflowQueue(BoundedInflowQueue.OverflowPolicy.DROP_INCOMING, storageInflowQueue);</span>
<span class="fc" id="L378">        this.swappableInflowQueue = new SwappableInflowQueue(boundedInflowQueue);</span>
<span class="fc" id="L379">        this.schedulerInflowQueue = new NotificationInflowQueue(swappableInflowQueue, q -&gt; updatePendingTasks(false, false, true));</span>
<span class="fc" id="L380">        this.syncInflowQueue = new SynchronizedInflowQueue(schedulerInflowQueue);</span>

<span class="fc bfc" id="L382" title="All 2 branches covered.">        for (int i = 0; i &lt; awaitLatches.length; i++)</span>
        {
<span class="fc" id="L384">            awaitLatches[i] = new CountDownLatch(1);</span>
        }
<span class="fc" id="L386">    }</span>

    /**
     * Retrieve the unique identifier of this actor.
     *
     * @return a UUID that uniquely identifies this actor in time and space.
     */
    public UUID uuid ()
    {
<span class="fc" id="L395">        return uuid;</span>
    }

    /**
     * Retrieve the cascade that contains this actor indirectly.
     *
     * @return the enclosing cascade.
     */
    public Cascade cascade ()
    {
<span class="fc" id="L405">        return stage().cascade();</span>
    }

    /**
     * Retrieve the stage that contains this actor.
     *
     * @return the enclosing stage.
     */
    public CascadeStage stage ()
    {
<span class="fc" id="L415">        return stage;</span>
    }

    /**
     * Retrieve the script that defines how this actor behaves.
     *
     * @return the script that will be executed whenever messages are received.
     */
    public CascadeScript script ()
    {
<span class="fc" id="L425">        return script;</span>
    }

    /**
     * Retrieve the context that this actor will pass to the script.
     *
     * @return the context that is passed to the script()
     * whenever messages are processed by this actor.
     */
    public CascadeContext context ()
    {
<span class="fc" id="L436">        return context;</span>
    }

    /**
     * Retrieve the performance metrics regarding this actor.
     *
     * @return useful metrics regarding this actor.
     */
    public ActorMetrics metrics ()
    {
<span class="fc" id="L446">        return metrics;</span>
    }

    /**
     * Changes the name of this actor.
     *
     * @param name will henceforth be the name of this actor.
     * @return this.
     */
    public CascadeActor setName (final String name)
    {
<span class="nc" id="L457">        requireEgg();</span>
<span class="nc" id="L458">        this.name = Objects.requireNonNull(name, &quot;name&quot;);</span>
<span class="nc" id="L459">        return this;</span>
    }

    /**
     * Retrieve the name of this actor.
     *
     * &lt;p&gt;
     * By default, the name of this actor is the string representation of the actor's UUID.
     * &lt;/p&gt;
     *
     * @return the current name of this actor.
     */
    public String getName ()
    {
<span class="fc" id="L473">        return name;</span>
    }

    /**
     * Replace the underlying power-source that powers this actor.
     *
     * @param executor will power this actor going forward.
     * @return this.
     */
    public CascadeActor setPowerSource (final CascadePowerSource executor)
    {
<span class="fc" id="L484">        requireEgg();</span>
<span class="fc" id="L485">        this.executor = Objects.requireNonNull(executor, &quot;executor&quot;);</span>
<span class="fc" id="L486">        return this;</span>
    }

    /**
     * Retrieve the underlying power-source.
     *
     * @return the current underlying power-source immediately.
     */
    public CascadePowerSource getPowerSource ()
    {
<span class="fc" id="L496">        return executor;</span>
    }

    /**
     * Causes this actor to switch to a fixed-size array-based
     * inflow-queue, which will be used to store the messages
     * that are pending processing by this actor.
     *
     * &lt;p&gt;
     * When backlogSize() reaches backlogCapacity().
     * the overflow-policy will dictate what happens
     * when new messages arrive for this actor.
     * &lt;/p&gt;
     *
     * @param capacity will be the backlogCapacity() of the queue.
     * @return this.
     */
    public CascadeActor setArrayInflowQueue (final int capacity)
    {
<span class="fc" id="L515">        requireEgg();</span>
<span class="fc" id="L516">        final BoundedInflowQueue.OverflowPolicy policy = boundedInflowQueue.policy();</span>
<span class="fc" id="L517">        final InflowQueue newQueue = new ArrayInflowQueue(capacity);</span>
<span class="fc" id="L518">        replaceQueue(policy, newQueue);</span>
<span class="fc" id="L519">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using an array-based inflow-queue.
     */
    public boolean hasArrayInflowQueue ()
    {
<span class="fc" id="L529">        return storageInflowQueue instanceof ArrayInflowQueue;</span>
    }

    /**
     * Causes this actor to switch to an fixed-size array-based
     * inflow-queue, which will be used to store the messages
     * that are pending processing by this actor.
     *
     * &lt;p&gt;
     * When backlogSize() reaches backlogCapacity().
     * the overflow-policy will dictate what happens
     * when new messages arrive for this actor.
     * &lt;/p&gt;
     *
     * @param capacity will be the backlogCapacity() of the queue.
     * @return this.
     */
    public CascadeActor setLinkedInflowQueue (final int capacity)
    {
<span class="nc" id="L548">        requireEgg();</span>
<span class="nc" id="L549">        final BoundedInflowQueue.OverflowPolicy policy = boundedInflowQueue.policy();</span>
<span class="nc" id="L550">        final InflowQueue newQueue = new LinkedInflowQueue(capacity);</span>
<span class="nc" id="L551">        replaceQueue(policy, newQueue);</span>
<span class="nc" id="L552">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using a linked-list based inflow-queue.
     */
    public boolean hasLinkedInflowQueue ()
    {
<span class="fc" id="L562">        return storageInflowQueue instanceof LinkedInflowQueue;</span>
    }

    /**
     * Causes the overflow-policy to be changed to Drop All.
     *
     * &lt;p&gt;
     * After this method returns, whenever backlogSize() reaches
     * backlogCapacity() and a new message arrives for processing
     * by this actor, the inflow-queue will be cleared
     * and the new message will also be dropped.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor setOverflowPolicyDropAll ()
    {
<span class="fc" id="L579">        requireEgg();</span>
<span class="fc" id="L580">        replaceQueue(BoundedInflowQueue.OverflowPolicy.DROP_ALL, storageInflowQueue);</span>
<span class="fc" id="L581">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using the Drop All overflow-policy.
     */
    public boolean isOverflowPolicyDropAll ()
    {
<span class="fc bfc" id="L591" title="All 2 branches covered.">        return boundedInflowQueue.policy() == BoundedInflowQueue.OverflowPolicy.DROP_ALL;</span>
    }

    /**
     * Causes the overflow-policy to be changed to Drop Pending.
     *
     * &lt;p&gt;
     * After this method returns, whenever backlogSize() reaches
     * backlogCapacity() and a new message arrives for processing
     * by this actor, the inflow-queue will be cleared and then
     * the new message will be enqueued.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor setOverflowPolicyDropPending ()
    {
<span class="fc" id="L608">        requireEgg();</span>
<span class="fc" id="L609">        replaceQueue(BoundedInflowQueue.OverflowPolicy.DROP_PENDING, storageInflowQueue);</span>
<span class="fc" id="L610">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using the Drop Pending overflow-policy.
     */
    public boolean isOverflowPolicyDropPending ()
    {
<span class="fc bfc" id="L620" title="All 2 branches covered.">        return boundedInflowQueue.policy() == BoundedInflowQueue.OverflowPolicy.DROP_PENDING;</span>
    }

    /**
     * Causes the overflow-policy to be changed to Drop Oldest.
     *
     * &lt;p&gt;
     * After this method returns, whenever backlogSize() reaches
     * backlogCapacity() and a new message arrives for processing
     * by this actor, the message that has been in the inflow-queue
     * for the longest period of time will be removed and then
     * the new message will be enqueued.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor setOverflowPolicyDropOldest ()
    {
<span class="fc" id="L638">        requireEgg();</span>
<span class="fc" id="L639">        replaceQueue(BoundedInflowQueue.OverflowPolicy.DROP_OLDEST, storageInflowQueue);</span>
<span class="fc" id="L640">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using the Drop Oldest overflow-policy.
     */
    public boolean isOverflowPolicyDropOldest ()
    {
<span class="fc bfc" id="L650" title="All 2 branches covered.">        return boundedInflowQueue.policy() == BoundedInflowQueue.OverflowPolicy.DROP_OLDEST;</span>
    }

    /**
     * Causes the overflow-policy to be changed to Drop Newest.
     *
     * &lt;p&gt;
     * After this method returns, whenever backlogSize() reaches
     * backlogCapacity() and a new message arrives for processing
     * by this actor, the message that has been in the inflow-queue
     * for the shortest period of time will be removed and then
     * the new message will be enqueued.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor setOverflowPolicyDropNewest ()
    {
<span class="fc" id="L668">        requireEgg();</span>
<span class="fc" id="L669">        replaceQueue(BoundedInflowQueue.OverflowPolicy.DROP_NEWEST, storageInflowQueue);</span>
<span class="fc" id="L670">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using the Drop Newest overflow-policy.
     */
    public boolean isOverflowPolicyDropNewest ()
    {
<span class="fc bfc" id="L680" title="All 2 branches covered.">        return boundedInflowQueue.policy() == BoundedInflowQueue.OverflowPolicy.DROP_NEWEST;</span>
    }

    /**
     * Causes the overflow-policy to be changed to Drop Incoming.
     *
     * &lt;p&gt;
     * After this method returns, whenever backlogSize() reaches
     * backlogCapacity() and a new message arrives for processing
     * by this actor, the message that has just arrived will be
     * dropped and no message will be enqueued. In short, messages
     * will only be enqueued when there is actually space available.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor setOverflowPolicyDropIncoming ()
    {
<span class="fc" id="L698">        requireEgg();</span>
<span class="fc" id="L699">        replaceQueue(BoundedInflowQueue.OverflowPolicy.DROP_INCOMING, storageInflowQueue);</span>
<span class="fc" id="L700">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return true, iff this actor is using the Drop Incoming overflow-policy.
     */
    public boolean isOverflowPolicyDropIncoming ()
    {
<span class="fc bfc" id="L710" title="All 2 branches covered.">        return boundedInflowQueue.policy() == BoundedInflowQueue.OverflowPolicy.DROP_INCOMING;</span>
    }

    /**
     * This method causes this actor to begin receiving messages for the given event.
     *
     * &lt;p&gt;
     * This method is a no-op, if this actor is already closing.
     * &lt;/p&gt;
     *
     * @param event identifies the event to listen for.
     * @return this.
     */
    public CascadeActor subscribe (final CascadeToken event)
    {
        /**
         * Synchronized to prevent concurrent unsubscriptions.
         *
         * When the actor dies, it will automatically unsubscribe from all subscriptions.
         * We must synchronize to prevent new subscriptions from occurring at the same time;
         * otherwise, a race-condition would exist that could cause a memory-leak.
         */
<span class="fc" id="L732">        synchronized (dispatcher)</span>
        {
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">            if (phase.get().ordinal() &lt; ActorLifeCycle.CLOSING.ordinal())</span>
            {
<span class="fc" id="L736">                subscriptions.add(event);</span>
<span class="fc" id="L737">                dispatcher.subscribe(event, this);</span>
            }
<span class="pc" id="L739">        }</span>

<span class="fc" id="L741">        return this;</span>
    }

    /**
     * This method causes this actor to stop receiving messages for the given event.
     *
     * &lt;p&gt;
     * If this actor is not currently subscribed to the given event,
     * then this method is simply a no-op.
     * &lt;/p&gt;
     *
     * @param event identifies the event to no longer listen for.
     * @return this.
     */
    public CascadeActor unsubscribe (final CascadeToken event)
    {
        /**
         * Synchronized to prevent concurrent subscriptions.
         */
<span class="fc" id="L760">        synchronized (dispatcher)</span>
        {
<span class="fc" id="L762">            dispatcher.unsubscribe(event, this);</span>
<span class="fc" id="L763">            subscriptions.remove(event);</span>
<span class="pc" id="L764">        }</span>
<span class="fc" id="L765">        return this;</span>
    }

    /**
     * Getter.
     *
     * @return the identities of the events that this actor is listening for.
     */
    public Set&lt;CascadeToken&gt; subscriptions ()
    {
<span class="nc" id="L775">        return ImmutableSet.copyOf(subscriptions);</span>
    }

    /**
     * Getter.
     *
     * @return the event-channels that this actor is currently subscribed-to.
     */
    public Set&lt;CascadeChannel&gt; inputs ()
    {
<span class="nc" id="L785">        final Set&lt;CascadeChannel&gt; set = subscriptions</span>
<span class="nc" id="L786">                .stream()</span>
<span class="nc" id="L787">                .map(evt -&gt; cascade().channelOf(evt).orElse(null))</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">                .filter(x -&gt; x != null)</span>
<span class="nc" id="L789">                .collect(Collectors.toSet());</span>

<span class="nc" id="L791">        return ImmutableSet.copyOf(set);</span>
    }

    /**
     * Getter.
     *
     * @return the life-cycle-phase that this actor is in.
     */
    public ActorLifeCycle getLifeCyclePhase ()
    {
<span class="fc" id="L801">        return phase.get();</span>
    }

    /**
     * Getter.
     *
     * @return true, if and only if, the script() is currently being executed.
     */
    public boolean isActing ()
    {
<span class="nc" id="L811">        return acting.get();</span>
    }

    /**
     * True, if the life-cycle-phase is neither EGG nor DEAD.
     *
     * @return true, iff this actor is still alive.
     */
    public boolean isAlive ()
    {
<span class="nc bnc" id="L821" title="All 4 branches missed.">        return getLifeCyclePhase() != ActorLifeCycle.EGG &amp;&amp; getLifeCyclePhase() != ActorLifeCycle.DEAD;</span>
    }

    /**
     * True, if this actor has already lived and then died.
     *
     * @return true, if this actor is now dead.
     */
    public boolean isDead ()
    {
<span class="fc bfc" id="L831" title="All 2 branches covered.">        return getLifeCyclePhase() == ActorLifeCycle.DEAD;</span>
    }

    /**
     * Sends an event-message directly to this actor.
     *
     * &lt;p&gt;
     * The event-message will *not* be routed through the global dispatcher;
     * therefore, no other actors will receive the event-message,
     * even if they are subscribed to the same event.
     * &lt;/p&gt;
     *
     * @param event identifies the event that produced the event-message.
     * @param stack is the content of the event-message.
     * @return this.
     */
    public CascadeActor tell (final CascadeToken event,
                              final CascadeStack stack)
    {
<span class="fc" id="L850">        Preconditions.checkNotNull(event, &quot;event&quot;);</span>
<span class="fc" id="L851">        Preconditions.checkNotNull(stack, &quot;stack&quot;);</span>
<span class="fc" id="L852">        syncInflowQueue.offer(event, stack);</span>
<span class="fc" id="L853">        return this;</span>
    }

    /**
     * Schedule this actor for startup.
     *
     * &lt;p&gt;
     * This method is a no-op, if start() or close() were already called.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor start ()
    {
<span class="fc" id="L867">        phaseTransitionIf(ActorLifeCycle.EGG, ActorLifeCycle.STARTING);</span>
<span class="fc" id="L868">        return this;</span>
    }

    /**
     * Cause this actor to perform one unit-of-work and then return.
     *
     * &lt;p&gt;
     * A single unit-of-work is either executing the startup-script,
     * processing a single incoming message using the message
     * handling script, or executing the stop-script.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Only one unit-of-work is performed during each invocation
     * in order to implement cooperative multi-tasking.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * If no work is immediately available, then this method is a no-op.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor crank ()
    {
        try
        {
<span class="fc" id="L895">            final long taskCount = updatePendingTasks(true, false, false);</span>

<span class="fc bfc" id="L897" title="All 2 branches covered.">            if (taskCount == 0)</span>
            {
<span class="fc" id="L899">                return this;</span>
            }

<span class="fc" id="L902">            synchronized (SELF)</span>
            {
<span class="fc" id="L904">                setupIfNeeded();</span>
<span class="fc" id="L905">                processMessageIfNeeded();</span>
<span class="fc" id="L906">                shutdownIfNeeded();</span>
<span class="pc" id="L907">            }</span>
        }
<span class="nc" id="L909">        catch (Throwable ex)</span>
        {
            /**
             * This should never actually happen.
             * If it does, something is seriously wrong.
             */
<span class="nc" id="L915">            unhandledExceptionCount.incrementAndGet();</span>
<span class="nc" id="L916">            ex.printStackTrace(System.err);</span>
        }
        finally
        {
<span class="pc" id="L920">            updatePendingTasks(false, true, false);</span>
<span class="pc" id="L921">        }</span>

<span class="fc" id="L923">        return this;</span>
    }

    /**
     * This method kills this actor, which causes it to stop listening
     * for incoming messages, remove itself from the stage, etc.
     *
     * &lt;p&gt;
     * This method returns immediately; however, the actor will not close
     * until it has finished any work that it is currently performing.
     * &lt;/p&gt;
     *
     * @return this.
     */
    public CascadeActor close ()
    {
        /**
         * Stop accepting new messages.
         * If new messages are sent, drop them immediately.
         */
<span class="fc" id="L943">        boundedInflowQueue.disable();</span>

        /**
         * Perform zero-or-one phase-transition.
         * Notice that the call order prevents more than one transition.
         */
<span class="fc" id="L949">        phaseTransitionIf(ActorLifeCycle.ACTIVE, ActorLifeCycle.CLOSING);</span>
<span class="fc" id="L950">        phaseTransitionIf(ActorLifeCycle.STARTING, ActorLifeCycle.CLOSING);</span>
<span class="fc" id="L951">        phaseTransitionIf(ActorLifeCycle.EGG, ActorLifeCycle.CLOSING);</span>

<span class="fc" id="L953">        return this;</span>
    }

    /**
     * This method blocks, until this actor starts.
     *
     * &lt;p&gt;
     * If this actor already started, then this method is a no-op.
     * &lt;/p&gt;
     *
     * @param goal is the life-cycle-phase that the thread will wait for the actor to reach.
     * @param timeout is the maximum amount of time to wait.
     * @return true, if the goal was reached.
     * @throws java.lang.InterruptedException
     */
    public boolean await (final ActorLifeCycle goal,
                          final Duration timeout)
            throws InterruptedException
    {
<span class="nc bnc" id="L972" title="All 2 branches missed.">        if (goal == ActorLifeCycle.EGG)</span>
        {
<span class="nc" id="L974">            return true;</span>
        }
        else
        {
<span class="nc" id="L978">            return awaitLatches[goal.ordinal() - 1].await(timeout.toNanos(), TimeUnit.NANOSECONDS);</span>
        }
    }

    private void setupIfNeeded ()
            throws Throwable
    {
<span class="fc bfc" id="L985" title="All 2 branches covered.">        if (phase.get() == ActorLifeCycle.STARTING)</span>
        {
            try
            {
<span class="fc" id="L989">                script.onSetup(context);</span>
            }
            finally
            {
<span class="pc" id="L993">                phaseTransitionIf(ActorLifeCycle.STARTING, ActorLifeCycle.ACTIVE);</span>
<span class="fc" id="L994">            }</span>
        }
<span class="fc" id="L996">    }</span>

    private void processMessageIfNeeded ()
            throws Throwable
    {
<span class="fc bfc" id="L1001" title="All 2 branches covered.">        if (phase.get() == ActorLifeCycle.ACTIVE)</span>
        {
<span class="fc" id="L1003">            event.set(null);</span>
<span class="fc" id="L1004">            stack.set(null);</span>
<span class="fc" id="L1005">            syncInflowQueue.removeOldest(event, stack);</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">            final boolean delivered = event.get() != null; // Not Always True (Overflow Effects)</span>
<span class="fc bfc" id="L1007" title="All 2 branches covered.">            if (delivered)</span>
            {
<span class="fc" id="L1009">                consumedMessageCount.incrementAndGet();</span>
<span class="fc" id="L1010">                script.onMessage(context(), event.get(), stack.get());</span>
            }
        }
<span class="fc" id="L1013">    }</span>

    private void shutdownIfNeeded ()
            throws Throwable
    {
        /**
         * If the actor is in the process of closing,
         * then continue processing messages,
         * until the queue is empty, which will occur,
         * because the queue is no longer accepting new messages.
         */
<span class="pc bpc" id="L1024" title="1 of 4 branches missed.">        if (phase.get() == ActorLifeCycle.CLOSING &amp;&amp; syncInflowQueue.isEmpty())</span>
        {
            try
            {
<span class="fc" id="L1028">                script().onClose(context);</span>
            }
            finally
            {
                /**
                 * Unsubscribe this actor from all event-channels that it is subscribed-to;
                 * otherwise, a memory-leak would occur, since the dispatcher would still
                 * have references to the actor, even though the actor is dead!
                 * Synchronized to prevent concurrent subscriptions.
                 */
<span class="pc" id="L1038">                synchronized (dispatcher)</span>
                {
<span class="pc" id="L1040">                    subscriptions.stream().forEach(s -&gt; unsubscribe(s));</span>
<span class="pc" id="L1041">                }</span>

                /**
                 * Remove this actor from the stage.
                 */
<span class="pc" id="L1046">                undertaker.accept(this);</span>

                /**
                 * This actor is now totally dead.
                 */
<span class="pc" id="L1051">                phaseTransitionIf(ActorLifeCycle.CLOSING, ActorLifeCycle.DEAD);</span>
<span class="fc" id="L1052">            }</span>
        }
<span class="fc" id="L1054">    }</span>

    /**
     * Update the counter that tracks the number of needed cranks
     * and notify the power-source as necessary.
     *
     * @param pre is true, if the call-site is the start of crank().
     * @param post is true, if the call-site is the end of crank().
     * @param add is true, if the call-site is a phase-transition
     * or due to receiving an event-message.
     * @return the number of pending cranks, if needed at the call-site.
     */
    private long updatePendingTasks (final boolean pre,
                                     final boolean post,
                                     final boolean add)
    {
        /**
         * Synchronize on the counter itself, rather than (this),
         * because we do *not* want to block, if the actor is executing.
         * Otherwise, we could not enqueue messages while executing, etc!
         */
<span class="fc" id="L1075">        synchronized (pendingTasks)</span>
        {
<span class="fc bfc" id="L1077" title="All 4 branches covered.">            if (add &amp;&amp; pendingTasks.get() == 0)</span>
            {
<span class="fc" id="L1079">                pendingTasks.incrementAndGet();</span>
<span class="fc" id="L1080">                executor.submit(this, pocket);</span>
            }
<span class="fc bfc" id="L1082" title="All 2 branches covered.">            else if (add)</span>
            {
<span class="fc" id="L1084">                pendingTasks.incrementAndGet();</span>
            }
<span class="fc bfc" id="L1086" title="All 2 branches covered.">            else if (pre)</span>
            {
<span class="fc" id="L1088">                return pendingTasks.get();</span>
            }
<span class="pc bpc" id="L1090" title="1 of 4 branches missed.">            else if (post &amp;&amp; pendingTasks.get() &gt; 1)</span>
            {
<span class="fc" id="L1092">                pendingTasks.decrementAndGet();</span>
<span class="fc" id="L1093">                executor.submit(this, pocket);</span>
            }
<span class="pc bpc" id="L1095" title="2 of 4 branches missed.">            else if (post &amp;&amp; pendingTasks.get() &lt;= 1)</span>
            {
<span class="fc" id="L1097">                pendingTasks.set(0);</span>
            }
            else
            {
<span class="nc" id="L1101">                Verify.verify(false, &quot;bug!&quot;);</span>
            }
<span class="pc" id="L1103">        }</span>

<span class="fc" id="L1105">        return -1;</span>
    }

    private void replaceQueue (final BoundedInflowQueue.OverflowPolicy policy,
                               final InflowQueue newStorageQueue)
    {
<span class="fc" id="L1111">        requireEgg();</span>
<span class="fc" id="L1112">        storageInflowQueue = newStorageQueue;</span>
<span class="fc" id="L1113">        boundedInflowQueue = new BoundedInflowQueue(policy, newStorageQueue);</span>
<span class="fc" id="L1114">        swappableInflowQueue.replaceDelegate(boundedInflowQueue);</span>
<span class="fc" id="L1115">    }</span>

    private boolean phaseTransitionIf (final ActorLifeCycle expected,
                                       final ActorLifeCycle next)
    {
<span class="pc bpc" id="L1120" title="1 of 2 branches missed.">        Verify.verify(next.ordinal() &gt; 0);</span>
<span class="pc bpc" id="L1121" title="1 of 2 branches missed.">        Verify.verify(ActorLifeCycle.values().length == 5, &quot;Regression Bug!&quot;);</span>

<span class="fc bfc" id="L1123" title="All 2 branches covered.">        if (phase.compareAndSet(expected, next))</span>
        {
<span class="fc" id="L1125">            awaitLatches[next.ordinal() - 1].countDown();</span>

            /**
             * All of the latches for the preceding phases must already be unblocked.
             */
<span class="pc bpc" id="L1130" title="1 of 2 branches missed.">            Verify.verify(IntStream.rangeClosed(0, next.ordinal() - 1).allMatch(i -&gt; awaitLatches[i].getCount() == 0));</span>

            /**
             * Tell the executor to turn the crank.
             */
<span class="fc" id="L1135">            updatePendingTasks(false, false, true);</span>

<span class="fc" id="L1137">            return true;</span>
        }
        else
        {
<span class="fc" id="L1141">            return false;</span>
        }
    }

    private void requireEgg ()
    {
<span class="pc bpc" id="L1147" title="1 of 2 branches missed.">        Preconditions.checkState(phase.get() == ActorLifeCycle.EGG, &quot;Already Hatched!&quot;);</span>
<span class="fc" id="L1148">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>